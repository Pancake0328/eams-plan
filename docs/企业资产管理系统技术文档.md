# 企业资产管理系统(EAMS)技术文档

## 摘要

企业资产管理系统(Enterprise Asset Management System，简称EAMS)是一个面向现代企业资产全生命周期管理需求的综合性信息管理系统。本系统采用前后端分离架构，基于Java Spring Boot和Vue 3技术栈，实现了从资产采购、入库、分配、流转、盘点、报修到报废的全流程数字化管理。系统引入了基于角色的访问控制(RBAC)权限体系，支持多层级部门管理，提供了丰富的统计分析功能和可视化仪表盘，有效提升了企业资产管理的效率和准确性。

本文档详细介绍了系统的技术选型、架构设计、功能模块、数据库设计、安全机制以及系统实现的关键技术，旨在为系统的开发、部署、维护和二次开发提供完整的技术参考。

**关键词**：资产管理、Spring Boot、Vue 3、RBAC权限、全生命周期管理、前后端分离

---

## 目录

1. [第一章 相关技术概述](#第一章-相关技术概述)
2. [第二章 系统分析](#第二章-系统分析)
3. [第三章 系统设计](#第三章-系统设计)
4. [第四章 系统实现](#第四章-系统实现)
5. [第五章 系统测试与部署](#第五章-系统测试与部署)
6. [第六章 总结与展望](#第六章-总结与展望)

---

## 第一章 相关技术概述

### 1.1 开发平台与工具

#### 1.1.1 开发平台
本系统采用跨平台开发模式，支持在Windows、Linux、macOS等主流操作系统上进行开发和部署。主要开发平台包括：

- **操作系统**: 
  - 开发环境：Windows 10/11、macOS 12+、Ubuntu 20.04+
  - 生产环境：Linux (CentOS 7+/Ubuntu 20.04+ 推荐)
  
- **Java开发环境**:
  - JDK 17 (LTS长期支持版本)
  - 支持Java 17的所有语言特性，包括记录类、模式匹配、密封类等

#### 1.1.2 开发工具
- **后端开发IDE**: IntelliJ IDEA 2023+ / Eclipse 2023+
- **前端开发IDE**: Visual Studio Code 1.80+
- **数据库管理工具**: Navicat Premium / MySQL Workbench / DBeaver
- **版本控制**: Git 2.30+
- **API测试**: Postman / Swagger UI
- **构建工具**: Maven 3.8+ (后端) / npm 9+ (前端)
- **容器化**: Docker 20+ / Docker Compose 2+ (可选)

### 1.2 软硬件环境

#### 1.2.1 服务器硬件环境
**最低配置**:
- CPU: 双核 2.0GHz以上
- 内存: 4GB RAM
- 硬盘: 50GB可用空间
- 网络: 100Mbps网络带宽

**推荐配置**:
- CPU: 四核 2.5GHz以上
- 内存: 8GB RAM以上
- 硬盘: 100GB SSD存储
- 网络: 1Gbps网络带宽

#### 1.2.2 客户端硬件环境
- CPU: 双核 1.5GHz以上
- 内存: 4GB RAM以上
- 显示器: 1920×1080分辨率以上
- 浏览器: Chrome 90+、Firefox 88+、Edge 90+、Safari 14+

#### 1.2.3 软件环境

**后端运行环境**:
- Java Runtime Environment (JRE) 17+
- MySQL 8.0+ 数据库
- Redis 6.0+ 缓存服务器
- Tomcat 10+ (内嵌，无需单独安装)

**前端运行环境**:
- Node.js 18+ (开发阶段)
- 现代浏览器 (生产环境)

### 1.3 后端技术栈

#### 1.3.1 核心框架
**Spring Boot 3.1.5**
- Spring Boot是基于Spring框架的快速开发脚手架，提供了自动配置、起步依赖、内嵌服务器等特性
- 版本3.1.5是稳定的生产级版本，兼容Java 17
- 内置Tomcat 10，简化了部署流程
- 提供了丰富的Starter依赖，简化配置

**Spring Framework 6.0**
- IoC容器：管理Bean的生命周期，实现依赖注入
- AOP：支持面向切面编程，用于日志记录、权限控制
- Spring MVC：实现RESTful API
- Spring Security：提供完整的安全解决方案

#### 1.3.2 持久层框架
**MyBatis Plus 3.5.7**
- 基于MyBatis的增强工具，在MyBatis基础上只做增强不做改变
- 内置通用Mapper，无需编写XML即可完成CRUD操作
- 支持Lambda表达式查询，类型安全
- 内置分页插件，简化分页查询
- 支持自动填充、逻辑删除、乐观锁等功能

#### 1.3.3 数据库
**MySQL 8.0**
- 开源关系型数据库，性能稳定可靠
- 支持事务、外键约束、存储过程
- InnoDB存储引擎，支持ACID特性
- 字符集：utf8mb4，完整支持Unicode字符集

#### 1.3.4 缓存中间件
**Redis 6.0+**
- 高性能键值对存储数据库
- 支持多种数据结构：String、Hash、List、Set、ZSet
- 用途：
  - 用户权限信息缓存
  - Token黑名单存储
  - 会话管理
  - 热点数据缓存

#### 1.3.5 安全框架
**Spring Security 6.1**
- 提供认证(Authentication)和授权(Authorization)功能
- 支持多种认证方式：表单登录、HTTP Basic、OAuth2等
- 与JWT集成实现无状态认证
- 支持方法级别的权限控制(@PreAuthorize)

**JWT (JSON Web Token)**
- jjwt 0.12.5：Java实现的JWT库
- 用于生成和验证Token
- Token有效期：7天 (604800秒)
- 采用HS256算法签名

#### 1.3.6 工具库
**Lombok**
- 通过注解自动生成getter、setter、toString等方法
- 减少样板代码，提高开发效率
- 常用注解：@Data、@Getter、@Setter、@Builder、@Slf4j

**Hutool 5.8.25**
- Java工具类库，提供丰富的工具方法
- 日期时间处理：DateUtil
- 字符串处理：StrUtil
- 加密解密：SecureUtil
- HTTP客户端：HttpUtil

**MapStruct 1.5.5**
- Java Bean映射框架，编译期生成映射代码
- 用于Entity、DTO、VO之间的转换
- 性能优于反射方式的映射工具

**Apache Commons**
- Commons Lang3：字符串、数组、日期等工具类
- Commons Pool2：连接池管理(Redis连接池)

#### 1.3.7 API文档
**SpringDoc OpenAPI 2.2.0 (Swagger 3)**
- 自动生成RESTful API文档
- 提供交互式API测试界面
- 支持注解增强文档信息
- 访问地址：http://localhost:8080/api/swagger-ui.html

#### 1.3.8 其他组件
**Apache POI 5.2.5**
- 用于读写Microsoft Office格式文档
- 支持Excel导入导出功能
- 用于资产数据批量导入和报表导出

**WebSocket**
- 实现服务端向客户端的实时推送
- 用于盘点进度通知、系统消息推送等场景

### 1.4 前端技术栈

#### 1.4.1 核心框架
**Vue 3.4.0**
- 采用Composition API开发模式
- 响应式系统基于Proxy实现
- 更好的TypeScript支持
- 性能优于Vue 2

**TypeScript 5.3.3**
- JavaScript的超集，添加了静态类型检查
- 提供更好的IDE支持和代码提示
- 减少运行时错误，提高代码质量
- 支持接口、泛型、装饰器等高级特性

#### 1.4.2 构建工具
**Vite 5.0.8**
- 下一代前端构建工具
- 基于ES Module的快速冷启动
- 热模块替换(HMR)速度快
- 生产环境基于Rollup打包
- 相比Webpack有更快的构建速度

#### 1.4.3 UI组件库
**Element Plus 2.5.0**
- 基于Vue 3的UI组件库
- 提供丰富的企业级组件：
  - 表单组件：输入框、选择器、日期选择等
  - 数据展示：表格、树形控件、分页等
  - 反馈组件：对话框、消息提示、加载等
  - 导航组件：菜单、标签页、面包屑等
- 支持按需引入，减小打包体积

**@element-plus/icons-vue 2.3.1**
- Element Plus官方图标库
- 提供200+常用图标
- 支持Vue组件方式使用

#### 1.4.4 状态管理
**Pinia 2.1.7**
- Vue 3官方推荐的状态管理库
- 替代Vuex的新一代方案
- 更好的TypeScript支持
- 更简洁的API设计
- 支持模块化Store

#### 1.4.5 路由管理
**Vue Router 4.2.5**
- Vue 3官方路由管理器
- 支持嵌套路由、动态路由
- 路由守卫功能实现权限控制
- 支持懒加载优化首屏性能

#### 1.4.6 HTTP客户端
**Axios 1.6.2**
- 基于Promise的HTTP客户端
- 支持请求/响应拦截器
- 自动转换JSON数据
- 支持取消请求
- 支持防止XSRF攻击

#### 1.4.7 数据可视化
**ECharts 6.0.0**
- 百度开源的可视化图表库
- 支持丰富的图表类型：
  - 折线图、柱状图、饼图
  - 雷达图、散点图、地图等
- 高度可定制化
- 支持响应式布局
- 用于仪表盘数据展示

### 1.5 开发规范与约定

#### 1.5.1 后端架构分层
系统采用经典的三层架构模式：

```
Controller层 → Service层 → Mapper层 → Database
    ↓            ↓           ↓
  DTO/VO        Entity      SQL
```

- **Controller层**：负责接收请求、参数校验、返回响应
- **Service层**：负责业务逻辑处理、事务管理
- **Mapper层**：负责数据访问、SQL执行

#### 1.5.2 数据传输对象规范
- **Entity**：数据库实体类，与表结构一一对应
- **DTO (Data Transfer Object)**：接收前端请求参数
- **VO (View Object)**：返回给前端的视图对象
- **三者分离原则**：不直接暴露Entity给前端

#### 1.5.3 统一响应格式
所有API接口统一使用Result<T>包装返回结果：

```json
{
  "code": 200,
  "message": "操作成功",
  "data": {}
}
```

#### 1.5.4 RESTful API设计规范
- GET：查询资源
- POST：创建资源
- PUT：完整更新资源
- PATCH：部分更新资源
- DELETE：删除资源

#### 1.5.5 命名规范
**后端命名规范**:
- 类名：大驼峰命名(PascalCase)，如UserService
- 方法名：小驼峰命名(camelCase)，如getUserById
- 常量名：全大写下划线分隔，如MAX_SIZE
- 包名：全小写，如com.eams.system

**前端命名规范**:
- 组件名：大驼峰命名，如UserManagement.vue
- 方法名：小驼峰命名，如fetchUserList
- 常量名：全大写下划线分隔，如API_BASE_URL

**数据库命名规范**:
- 表名：小写下划线分隔，如sys_user
- 字段名：小写下划线分隔，如create_time
- 索引名：idx_表名_字段名，如idx_user_username

---

## 第二章 系统分析

### 2.1 可行性分析

#### 2.1.1 技术可行性

本系统采用的技术栈均为成熟稳定的开源技术，具有以下技术可行性：

1. **技术成熟度高**
   - Spring Boot、Vue 3等核心技术已在业界广泛应用
   - 拥有完善的文档和活跃的社区支持
   - 技术生态成熟，第三方库丰富

2. **开发效率高**
   - Spring Boot自动配置减少开发工作量
   - MyBatis Plus提供通用CRUD，无需编写重复代码
   - Vue 3 + Element Plus快速构建界面
   - 前后端分离，可并行开发

3. **性能表现优异**
   - Spring Boot轻量级，启动速度快
   - MyBatis Plus优化的SQL执行效率高
   - Redis缓存提升响应速度
   - Vue 3虚拟DOM和响应式系统性能优秀

4. **扩展性强**
   - 模块化设计，便于功能扩展
   - RESTful API设计，便于集成其他系统
   - 支持微服务架构改造
   - 数据库表设计预留扩展字段

5. **安全性可靠**
   - Spring Security提供企业级安全框架
   - JWT Token无状态认证
   - RBAC权限模型精细控制访问权限
   - SQL注入、XSS等常见攻击有防护机制

#### 2.1.2 经济可行性

**开发成本分析**:
1. **技术栈成本**：全部采用开源技术，无需支付许可证费用
2. **开发人员成本**：
   - 后端开发：2人，6个月
   - 前端开发：1人，6个月
   - 数据库设计：1人（兼职），2个月
   - 测试人员：1人，3个月
3. **硬件成本**：中等配置服务器，约5000-10000元
4. **其他成本**：开发工具、域名、SSL证书等，约5000元

**预期收益**:
1. **提高管理效率**：资产流转全流程数字化，减少人工操作
2. **降低资产流失**：盘点功能及时发现资产异常
3. **优化资源配置**：数据统计分析辅助决策
4. **节约成本**：减少纸质单据和人工记录成本
5. **提升数据准确性**：系统自动计算折旧，减少人为错误

综合评估，系统开发投入产出比合理，具有良好的经济可行性。

#### 2.1.3 操作可行性

1. **用户界面友好**
   - Element Plus提供美观现代的UI组件
   - 操作流程符合用户习惯
   - 支持键盘快捷键操作
   - 表单验证提供即时反馈

2. **学习成本低**
   - 界面布局清晰，功能分类合理
   - 提供操作说明和帮助文档
   - 关键操作有确认提示
   - 错误提示信息明确

3. **部署维护简单**
   - Spring Boot打包为单一jar文件
   - 前端打包为静态资源，可部署到任何Web服务器
   - 提供Docker镜像，一键部署
   - 支持自动备份和恢复

4. **培训支持**
   - 提供用户手册和视频教程
   - 支持在线客服和技术支持
   - 定期更新和功能优化

#### 2.1.4 法律可行性

1. **知识产权**：
   - 所有开源组件遵循其开源协议（Apache 2.0、MIT等）
   - 自主开发代码拥有完整知识产权
   - 不侵犯第三方专利和版权

2. **数据安全与隐私**：
   - 符合《中华人民共和国网络安全法》要求
   - 符合《中华人民共和国数据安全法》要求
   - 用户数据加密存储和传输
   - 提供数据导出和删除功能

3. **软件许可**：
   - 本系统采用Apache License 2.0开源协议
   - 允许商业使用、修改、分发
   - 需保留原作者版权声明

### 2.2 功能性需求分析

#### 2.2.1 用户角色定义

本系统支持以下用户角色：

1. **系统管理员(Admin)**
   - 拥有系统所有权限
   - 管理用户、角色、部门
   - 配置系统参数
   - 查看系统日志和审计信息

2. **资产管理员(Asset Manager)**
   - 管理资产信息和分类
   - 审批资产流转申请
   - 创建和执行盘点计划
   - 查看资产统计报表

3. **采购人员(Purchaser)**
   - 创建采购申请单
   - 办理资产入库
   - 管理供应商信息
   - 查看采购统计

4. **部门负责人(Department Manager)**
   - 查看本部门资产
   - 申请资产调拨
   - 审批本部门资产申请
   - 查看部门资产报表

5. **普通员工(Employee)**
   - 查看个人名下资产
   - 申请领用资产
   - 报修资产故障
   - 办理资产归还

6. **维修人员(Maintenance Staff)**
   - 查看报修单
   - 更新维修进度
   - 完成维修记录
   - 查看维修历史

#### 2.2.2 功能模块概述

系统共分为8个主要功能模块：

**1. 系统管理模块**
- 用户管理：新增、编辑、删除、启用/禁用用户
- 角色管理：角色CRUD、权限分配
- 部门管理：部门树形结构管理
- 菜单管理：菜单/按钮权限配置
- 权限管理：用户角色分配、权限查询

**2. 仪表盘模块**
- 资产概览：总资产数、在用数、闲置数、报废数
- 资产分布统计：按部门、分类、状态分布
- 时间趋势图：资产新增/报废趋势
- 采购统计：采购金额、采购数量统计
- 预警提醒：待审批、待维修、待盘点提醒

**3. 资产管理模块**
- 资产分类：树形分类管理，支持多级分类
- 资产信息：资产CRUD、批量导入导出
- 资产详情：基本信息、折旧信息、流转历史
- 资产编码：自动生成唯一资产编号
- 资产搜索：多条件组合搜索、高级筛选

**4. 资产流转模块**
- 入库管理：采购入库、批量入库
- 资产分配：分配资产给员工或部门
- 资产调拨：部门间资产转移
- 资产归还：员工归还资产
- 资产送修：送修登记、关联报修单
- 资产报废：报废申请、审批、执行
- 流转记录：完整的流转历史追溯

**5. 采购管理模块**
- 采购申请：创建采购单，填写采购明细
- 采购审批：审批流程、审批记录
- 采购入库：关联采购单办理入库
- 采购统计：采购金额、数量、供应商统计
- 账单管理：月度/年度账单生成和查询
- 资金统计：采购资金流向分析

**6. 生命周期管理模块**
- 生命周期跟踪：记录资产各阶段状态变化
- 状态定义：购入、使用中、维修中、闲置、报废、取消采购
- 状态流转：状态变更记录、变更原因
- 历史查询：完整的生命周期历史
- 当前状态：快速查看资产当前阶段

**7. 盘点管理模块**
- 盘点计划：创建全面盘点、专项盘点、抽样盘点
- 盘点执行：扫描资产、记录盘点结果
- 盘点结果：正常、位置异常、状态异常、丢失
- 异常处理：标记异常资产、更新位置信息
- 盘点报告：盘点统计、异常资产清单

**8. 报修管理模块**
- 报修申请：员工提交报修申请
- 报修类型：日常维修、故障维修、预防性维修
- 优先级：紧急、普通、低
- 审批流程：报修审批、分配维修人员
- 维修跟踪：维修进度更新、完成记录
- 报修历史：查看资产报修历史

#### 2.2.3 核心功能详细需求

**功能1：资产全生命周期管理**

*需求描述*：
系统需要跟踪资产从采购到报废的完整生命周期，每个阶段的变化都要有详细记录。

*功能要点*：
1. 采购阶段：创建采购单后自动生成资产记录，状态为"购入"
2. 入库阶段：办理入库后资产状态变为"闲置"，可供分配
3. 使用阶段：分配给员工或部门后状态变为"使用中"
4. 维修阶段：送修后状态变为"维修中"，维修完成后恢复"使用中"或"闲置"
5. 报废阶段：报废审批通过后状态变为"已报废"，不可再使用
6. 每次状态变更需记录：变更时间、操作人、变更原因、变更前后部门和责任人

*数据要求*：
- 生命周期记录永久保存，不可删除
- 支持按时间范围查询历史
- 支持按资产ID查询完整生命周期
- 提供生命周期可视化时间轴展示

**功能2：RBAC权限管理**

*需求描述*：
系统采用基于角色的访问控制，实现用户、角色、权限三级管理，确保数据安全和操作规范。

*功能要点*：
1. 用户管理：支持用户CRUD、启用/禁用、密码重置、角色分配
2. 角色管理：支持角色CRUD、权限分配、角色状态管理
3. 权限管理：菜单权限（页面访问）、按钮权限（操作权限）、接口权限（API访问）
4. 权限标识：采用"模块:资源:操作"三段式命名，如"asset:info:edit"
5. 权限校验：前端控制菜单和按钮可见性，后端强制校验接口权限
6. 权限继承：用户通过角色继承权限，支持多角色

*实现要求*：
- 登录时加载用户权限集合，缓存到Redis
- 前端使用v-permission指令控制元素显示
- 后端使用@PreAuthorize注解控制接口访问
- 权限变更后需重新登录生效

**功能3：资产盘点管理**

*需求描述*：
支持定期或不定期对资产进行盘点，及时发现资产异常情况，确保账实相符。

*功能要点*：
1. 盘点类型：
   - 全面盘点：盘点所有资产
   - 专项盘点：指定资产分类盘点
   - 抽样盘点：随机抽取指定数量资产盘点
2. 盘点流程：
   - 创建盘点计划 → 生成盘点明细 → 执行盘点 → 记录结果 → 完成盘点
3. 盘点结果：
   - 正常：资产实物与账面一致
   - 位置异常：资产存在但位置不符
   - 状态异常：资产存在但状态不符
   - 丢失：资产账面存在但实物未找到
4. 异常处理：
   - 自动标记异常资产
   - 支持更新资产位置
   - 丢失资产自动标记并上报
5. 盘点报告：
   - 盘点统计：正常/异常数量、盘点率
   - 异常清单：详细的异常资产列表
   - 支持导出Excel报告

*数据要求*：
- 盘点明细支持分页查询，避免一次加载过多数据
- 盘点结果不可修改，保证数据真实性
- 盘点记录永久保存，便于审计追溯

**功能4：资产折旧计算**

*需求描述*：
系统自动计算资产折旧，生成月度和年度账单，为财务核算提供数据支持。

*功能要点*：
1. 折旧方法：采用直线法（平均年限法）
2. 计算公式：
   - 月折旧额 = (采购金额 - 残值) / 使用年限（月）
   - 累计折旧 = 月折旧额 × 已使用月数
   - 净值 = 采购金额 - 累计折旧
3. 关键参数：
   - 采购金额：资产原始购入价格
   - 残值率：默认5%，可配置
   - 使用年限：默认60个月（5年），可配置
4. 特殊处理：
   - 报废资产停止计提折旧
   - 闲置资产继续计提折旧
   - 累计折旧不超过(采购金额-残值)
5. 账单生成：
   - 月度账单：每月1日自动生成上月账单
   - 年度账单：每年1月1日自动生成上年账单
   - 账单内容：折旧总额、资产净值、新增资产等

*实现要求*：
- 金额计算使用BigDecimal，精度为2位小数
- 采用四舍五入舍入模式
- 账单生成加锁，避免重复生成
- 已生成账单不可修改，只能作废重新生成

**功能5：统计分析与仪表盘**

*需求描述*：
提供丰富的统计图表和数据分析功能，直观展示资产管理情况。

*功能要点*：
1. 资产概览：
   - 总资产数量和金额
   - 在用、闲置、维修中、报废资产数量
   - 资产净值总额
2. 分布统计：
   - 按部门分布：饼图/柱状图
   - 按分类分布：饼图/树图
   - 按状态分布：饼图/柱状图
3. 时间趋势：
   - 资产新增趋势：折线图
   - 资产报废趋势：折线图
   - 采购金额趋势：柱状图
4. 采购统计：
   - 采购金额统计：按月/季度/年
   - 采购数量统计：按分类统计
   - 供应商统计：采购次数、金额排名
5. 实时数据：
   - 使用WebSocket推送实时数据
   - 自动刷新，无需手动刷新页面

*展示要求*：
- 使用ECharts图表库实现可视化
- 支持图表交互，点击查看详情
- 支持图表导出为图片
- 响应式布局，适配不同屏幕

### 2.3 非功能性需求分析

#### 2.3.1 性能需求

**响应时间**:
- 页面加载时间：首屏≤3秒
- 接口响应时间：普通查询≤500ms，复杂查询≤2秒
- 批量操作：1000条数据导入≤30秒

**并发能力**:
- 支持100+并发用户同时在线
- 支持500+QPS（每秒请求数）
- 数据库连接池：最小10，最大50

**数据容量**:
- 资产数据：支持10万+资产记录
- 流转记录：支持100万+流转记录
- 生命周期记录：支持100万+生命周期记录
- 盘点记录：支持历史盘点数据无限存储

**系统资源**:
- 后端JVM内存：推荐2GB-4GB
- Redis内存：推荐512MB-1GB
- MySQL存储：推荐100GB以上
- 带宽：推荐10Mbps以上

#### 2.3.2 可靠性需求

**可用性**:
- 系统可用率：≥99.5%
- 计划内停机维护：每月≤4小时
- 故障恢复时间：≤1小时

**数据完整性**:
- 数据库事务保证ACID特性
- 关键操作记录日志
- 定期数据备份（每日全量+实时增量）
- 数据恢复时间：≤2小时

**容错性**:
- 异常处理：所有异常都有友好提示
- 输入验证：前后端双重验证
- 并发控制：乐观锁/悲观锁防止数据冲突
- 降级策略：缓存不可用时直连数据库

#### 2.3.3 安全性需求

**认证与授权**:
- 用户身份认证：用户名密码+JWT Token
- 会话管理：Token有效期7天，支持续期
- 权限控制：RBAC模型，细粒度权限控制
- 密码策略：BCrypt加密，禁止明文存储

**数据安全**:
- 传输加密：HTTPS协议
- 敏感数据加密：密码、身份证号等
- SQL注入防护：MyBatis预编译语句
- XSS攻击防护：前端转义输出

**审计与日志**:
- 操作日志：记录关键操作（登录、修改、删除等）
- 审计日志：记录用户、时间、操作内容、IP地址
- 异常日志：记录系统异常和错误
- 日志保留期：≥6个月

**备份与恢复**:
- 数据库备份：每日全量备份
- 文件备份：上传文件定期备份
- 备份存储：异地存储，多份冗余
- 恢复测试：每季度进行一次恢复演练

#### 2.3.4 易用性需求

**界面设计**:
- 符合Material Design设计规范
- 统一的配色方案和视觉风格
- 清晰的页面布局和导航
- 响应式设计，支持移动端访问（可选）

**操作便捷**:
- 常用功能快捷入口
- 批量操作功能
- 智能搜索和筛选
- 表格列自定义显示
- 快捷键支持

**提示与帮助**:
- 操作说明和帮助文档
- 表单验证即时反馈
- 错误提示明确具体
- 成功操作给予反馈

**国际化**:
- 支持中文界面
- 时间格式：yyyy-MM-dd HH:mm:ss
- 金额格式：千分位分隔

#### 2.3.5 可维护性需求

**代码质量**:
- 代码规范：遵循阿里巴巴Java开发手册
- 注释完整：关键方法有注释说明
- 命名规范：见名知意，统一命名风格
- 代码重用：抽取公共方法和组件

**文档完整**:
- 需求文档：功能需求说明
- 设计文档：架构设计、数据库设计
- 接口文档：API接口说明（Swagger自动生成）
- 部署文档：安装部署指南
- 用户手册：用户操作手册

**可测试性**:
- 单元测试：核心业务逻辑编写单元测试
- 集成测试：接口测试覆盖主要API
- 测试覆盖率：≥60%

**可监控性**:
- 日志记录：完整的日志记录
- 健康检查：/actuator/health端点
- 性能监控：JVM内存、CPU、线程监控
- 慢查询监控：记录执行时间>2秒的SQL

#### 2.3.6 兼容性需求

**浏览器兼容**:
- Chrome 90+（推荐）
- Firefox 88+
- Microsoft Edge 90+
- Safari 14+
- 不支持IE浏览器

**数据库兼容**:
- MySQL 8.0+
- MariaDB 10.5+（兼容）

**操作系统兼容**:
- Linux (CentOS 7+/Ubuntu 20.04+)
- Windows Server 2016+
- macOS 12+

---

## 第三章 系统设计

### 3.1 系统架构设计

#### 3.1.1 总体架构

EAMS系统采用前后端分离的B/S架构，整体架构分为四层：

```
┌─────────────────────────────────────────────────┐
│              展现层 (Presentation Layer)           │
│     Vue 3 + Element Plus + ECharts               │
│     用户界面、数据可视化、交互逻辑                    │
└─────────────────────────────────────────────────┘
                        ↓ HTTP/HTTPS + JWT
┌─────────────────────────────────────────────────┐
│              接口层 (API Layer)                    │
│     Spring MVC + RESTful API                     │
│     请求处理、参数校验、响应封装                       │
└─────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────┐
│            业务逻辑层 (Business Layer)              │
│     Spring Service + 业务流程                      │
│     业务处理、事务管理、规则校验                       │
└─────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────┐
│            数据访问层 (Data Access Layer)           │
│     MyBatis Plus + MySQL                         │
│     数据持久化、查询优化、缓存管理                     │
└─────────────────────────────────────────────────┘
```

**层次说明**:

1. **展现层**：
   - 责任：用户交互、数据展示、前端路由、状态管理
   - 技术：Vue 3、TypeScript、Element Plus、ECharts、Axios
   - 特点：单页应用(SPA)、组件化开发、响应式设计

2. **接口层**：
   - 责任：接收HTTP请求、调用业务逻辑、返回JSON响应
   - 技术：Spring MVC、Spring Security、JWT、Validation
   - 特点：RESTful风格、统一响应格式、统一异常处理

3. **业务逻辑层**:
   - 责任：实现业务逻辑、事务管理、数据转换
   - 技术：Spring Service、Spring AOP、MapStruct
   - 特点：事务控制、业务封装、面向接口编程

4. **数据访问层**:
   - 责任：数据持久化、SQL执行、缓存管理
   - 技术：MyBatis Plus、MySQL、Redis
   - 特点：ORM映射、分页插件、逻辑删除

#### 3.1.2 技术架构图

```
┌────────────────────────── 前端技术栈 ─────────────────────────────┐
│                                                                    │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐        │
│  │  Vue 3   │  │TypeScript│  │  Vite    │  │ Element  │        │
│  │          │  │          │  │          │  │   Plus   │        │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘        │
│                                                                    │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐        │
│  │  Pinia   │  │   Axios  │  │  Router  │  │ ECharts  │        │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘        │
│                                                                    │
└────────────────────────────────────────────────────────────────┘
                               ↓
                       HTTP/HTTPS + JWT Token
                               ↓
┌────────────────────────── 后端技术栈 ─────────────────────────────┐
│                                                                    │
│  ┌────────────────── Spring Boot 3.1.5 ─────────────────────┐   │
│  │                                                             │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐ │   │
│  │  │  Spring  │  │  Spring  │  │  Spring  │  │  Spring  │ │   │
│  │  │   MVC    │  │ Security │  │   AOP    │  │   Data   │ │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └──────────┘ │   │
│  │                                                             │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                    │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐        │
│  │ MyBatis  │  │   JWT    │  │  Lombok  │  │ Hutool   │        │
│  │   Plus   │  │          │  │          │  │          │        │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘        │
│                                                                    │
└────────────────────────────────────────────────────────────────┘
                               ↓
┌────────────────────────── 数据存储层 ─────────────────────────────┐
│                                                                    │
│  ┌──────────────────┐              ┌──────────────────┐          │
│  │   MySQL 8.0      │              │   Redis 6.0      │          │
│  │                  │              │                  │          │
│  │  - 业务数据存储    │              │  - 缓存存储        │          │
│  │  - 事务支持        │              │  - 会话管理        │          │
│  │  - InnoDB引擎     │              │  - Token黑名单     │          │
│  └──────────────────┘              └──────────────────┘          │
│                                                                    │
└────────────────────────────────────────────────────────────────┘
```

#### 3.1.3 部署架构

EAMS系统支持多种部署方式：

**单机部署架构**（适用于小规模企业）:
```
┌─────────────────────────────────────┐
│        Application Server            │
│  ┌────────────────────────────────┐ │
│  │   Nginx (静态资源+反向代理)       │ │
│  │   Port: 80/443                  │ │
│  └────────────────────────────────┘ │
│  ┌────────────────────────────────┐ │
│  │   Spring Boot Application       │ │
│  │   Port: 8080                    │ │
│  └────────────────────────────────┘ │
│  ┌────────────────────────────────┐ │
│  │   MySQL 8.0                     │ │
│  │   Port: 3306                    │ │
│  └────────────────────────────────┘ │
│  ┌────────────────────────────────┐ │
│  │   Redis 6.0                     │ │
│  │   Port: 6379                    │ │
│  └────────────────────────────────┘ │
└─────────────────────────────────────┘
```

**分布式部署架构**（适用于大规模企业）:
```
            ┌──────────────┐
            │   Nginx LB   │  负载均衡
            │   Port: 80   │
            └──────────────┘
                   │
        ┌──────────┴──────────┐
        │                      │
  ┌─────────┐          ┌─────────┐
  │  Web1   │          │  Web2   │  Web服务器
  │ Vue静态 │          │ Vue静态 │
  └─────────┘          └─────────┘
        │                      │
        └──────────┬───────────┘
                   │
            ┌──────────────┐
            │   Nginx LB   │  负载均衡
            └──────────────┘
                   │
        ┌──────────┴──────────┐
        │                      │
  ┌─────────┐          ┌─────────┐
  │  App1   │          │  App2   │  应用服务器
  │ :8080   │          │ :8080   │
  └─────────┘          └─────────┘
        │                      │
        └──────────┬───────────┘
                   │
        ┌──────────┴──────────┐
        │                      │
  ┌─────────┐          ┌─────────┐
  │ MySQL   │←─主从──→│ MySQL   │  数据库主从
  │ Master  │  复制   │ Slave   │
  └─────────┘          └─────────┘
        │
  ┌─────────┐
  │  Redis  │  缓存服务器
  │ Cluster │
  └─────────┘
```

#### 3.1.4 安全架构

系统采用多层次的安全防护机制：

```
┌────────────────────── 安全防护层次 ──────────────────────┐
│                                                            │
│  第1层：网络安全                                            │
│  ┌────────────────────────────────────────────────────┐  │
│  │  - 防火墙规则                                        │  │
│  │  - HTTPS加密传输                                     │  │
│  │  - DDoS防护                                          │  │
│  └────────────────────────────────────────────────────┘  │
│                          ↓                                 │
│  第2层：应用安全                                            │
│  ┌────────────────────────────────────────────────────┐  │
│  │  - JWT Token认证                                     │  │
│  │  - RBAC权限控制                                      │  │
│  │  - CORS跨域限制                                      │  │
│  │  - XSS过滤                                           │  │
│  │  - CSRF防护                                          │  │
│  └────────────────────────────────────────────────────┘  │
│                          ↓                                 │
│  第3层：数据安全                                            │
│  ┌────────────────────────────────────────────────────┐  │
│  │  - SQL注入防护(预编译)                               │  │
│  │  - 敏感数据加密(BCrypt)                              │  │
│  │  - 数据库访问控制                                     │  │
│  │  - 数据备份策略                                       │  │
│  └────────────────────────────────────────────────────┘  │
│                          ↓                                 │
│  第4层：审计安全                                            │
│  ┌────────────────────────────────────────────────────┐  │
│  │  - 操作日志记录                                       │  │
│  │  - 异常日志监控                                       │  │
│  │  - 审计追溯                                           │  │
│  └────────────────────────────────────────────────────┘  │
│                                                            │
└────────────────────────────────────────────────────────┘
```

### 3.2 功能模块设计

系统功能模块采用分层模块化设计，每个模块职责清晰、低耦合高内聚。

#### 3.2.1 模块划分


系统按照业务领域划分为8个主要功能模块：

```
EAMS 系统
├── 系统管理模块 (system)
│   ├── 用户管理
│   ├── 角色管理
│   ├── 部门管理
│   └── 权限管理
├── 仪表盘模块 (dashboard)
│   ├── 数据概览
│   ├── 统计图表
│   └── 趋势分析
├── 资产管理模块 (asset)
│   ├── 资产分类管理
│   ├── 资产信息管理
│   └── 资产流转管理
├── 采购管理模块 (purchase)
│   ├── 采购单管理
│   ├── 采购入库
│   ├── 账单管理
│   └── 资金统计
├── 生命周期模块 (lifecycle)
│   ├── 生命周期追踪
│   ├── 状态流转
│   └── 历史查询
├── 盘点管理模块 (inventory)
│   ├── 盘点计划
│   ├── 盘点执行
│   └── 盘点报告
├── 报修管理模块 (repair)
│   ├── 报修申请
│   ├── 报修审批
│   └── 维修跟踪
└── 流转记录模块 (record)
    ├── 入库记录
    ├── 分配记录
    ├── 调拨记录
    ├── 归还记录
    ├── 送修记录
    └── 报废记录
```

#### 3.2.2 模块间关系

**模块依赖关系图**:
```
                    ┌──────────────┐
                    │  系统管理模块  │
                    │  (基础模块)   │
                    └──────────────┘
                           │
              ┌────────────┼────────────┐
              │            │            │
      ┌──────────┐  ┌──────────┐  ┌──────────┐
      │ 用户管理  │  │ 角色管理  │  │ 部门管理  │
      └──────────┘  └──────────┘  └──────────┘
              │            │            │
              └────────────┼────────────┘
                           ↓
                    ┌──────────────┐
                    │  权限管理模块  │
                    └──────────────┘
                           │
        ┌──────────────────┼──────────────────┐
        ↓                  ↓                  ↓
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│  资产管理模块  │  │  采购管理模块  │  │  盘点管理模块  │
└──────────────┘  └──────────────┘  └──────────────┘
        │                  │                  │
        └──────────────────┼──────────────────┘
                           ↓
                  ┌──────────────┐
                  │ 生命周期模块  │
                  └──────────────┘
                           │
                  ┌────────┴────────┐
                  ↓                 ↓
          ┌──────────────┐  ┌──────────────┐
          │ 流转记录模块  │  │ 报修管理模块  │
          └──────────────┘  └──────────────┘
                  │                 │
                  └────────┬────────┘
                           ↓
                  ┌──────────────┐
                  │  仪表盘模块   │
                  └──────────────┘
```

#### 3.2.3 核心模块详细设计

**模块1: 系统管理模块**

*模块职责*:
- 管理系统用户、角色、部门、权限
- 实现RBAC权限体系
- 提供用户认证和授权功能

*子模块设计*:

**用户管理子模块**:
- 功能：用户CRUD、启用/禁用、密码重置、角色分配
- 主要类：
  - UserController: 处理用户相关请求
  - UserService: 用户业务逻辑
  - UserMapper: 用户数据访问
  - User (Entity): 用户实体
  - UserVO: 用户视图对象
  - UserCreateRequest/UserUpdateRequest: 用户DTO

**角色管理子模块**:
- 功能：角色CRUD、权限分配、角色状态管理
- 主要类：
  - RoleController: 处理角色相关请求
  - RoleService: 角色业务逻辑
  - RoleMapper: 角色数据访问
  - Role (Entity): 角色实体

**部门管理子模块**:
- 功能：部门树形结构管理、部门CRUD
- 主要类：
  - DepartmentController: 处理部门相关请求
  - DepartmentService: 部门业务逻辑
  - DepartmentMapper: 部门数据访问

**权限管理子模块**:
- 功能：菜单权限管理、用户权限查询、权限校验
- 主要类：
  - PermissionController: 处理权限相关请求
  - PermissionService: 权限业务逻辑
  - Menu (Entity): 菜单权限实体

**模块2: 资产管理模块**

*模块职责*:
- 管理资产基本信息和分类
- 处理资产流转操作
- 记录资产流转历史

*子模块设计*:

**资产信息管理**:
- 功能：资产CRUD、批量导入导出、资产搜索
- 关键字段：
  - 基本信息：资产编号、名称、型号、规格
  - 采购信息：采购日期、采购价格、供应商
  - 使用信息：使用部门、责任人、存放位置
  - 状态信息：资产状态、生命周期阶段
- 主要类：
  - AssetInfoController
  - AssetInfoService
  - AssetInfoMapper
  - AssetInfo (Entity)

**资产分类管理**:
- 功能：分类树形管理、分类CRUD
- 特点：支持多级分类、父子关系维护
- 主要类：
  - AssetCategoryController
  - AssetCategoryService
  - AssetCategoryMapper
  - AssetCategory (Entity)

**资产流转管理**:
- 功能：入库、分配、调拨、归还、送修、报废
- 流程：
  1. 用户发起流转申请
  2. 系统校验资产状态
  3. 更新资产信息
  4. 记录流转记录
  5. 更新生命周期
- 主要类：
  - AssetRecordController
  - AssetRecordService
  - AssetRecordMapper
  - AssetRecord (Entity)

**模块3: 采购管理模块**

*模块职责*:
- 管理资产采购流程
- 生成采购账单和资金统计
- 计算资产折旧

*子模块设计*:

**采购单管理**:
- 功能：创建采购单、采购明细、采购审批
- 流程：创建采购单 → 审批 → 入库 → 生成资产
- 主要类：
  - PurchaseController
  - PurchaseService
  - PurchaseOrder (Entity)
  - PurchaseDetail (Entity)

**账单管理**:
- 功能：月度/年度账单生成、账单查询、账单确认
- 计算内容：折旧总额、资产净值、新增资产
- 主要类：
  - BillController
  - BillService
  - Bill (Entity)

**资金统计**:
- 功能：采购资金统计、按时间/部门/分类统计
- 主要类：
  - FinanceStatisticsService

**模块4: 生命周期管理模块**

*模块职责*:
- 跟踪资产全生命周期
- 记录状态变更历史
- 提供生命周期查询

*关键设计*:

**生命周期阶段**:
1. 购入 (PURCHASE) - 采购完成
2. 使用中 (IN_USE) - 正常使用
3. 维修中 (REPAIRING) - 送修维修
4. 闲置 (IDLE) - 未使用
5. 报废 (SCRAPPED) - 已报废
6. 取消采购 (CANCELLED) - 采购取消

**状态流转规则**:
- 购入 → 闲置/取消采购
- 使用中 → 维修中/闲置/报废
- 维修中 → 使用中/闲置/报废
- 闲置 → 使用中/报废
- 报废/取消采购 → (最终状态，不可变更)

*主要类*:
- AssetLifecycleController
- AssetLifecycleService
- AssetLifecycle (Entity)

**模块5: 盘点管理模块**

*模块职责*:
- 创建和执行盘点计划
- 记录盘点结果
- 处理盘点异常

*盘点类型*:
1. 全面盘点：盘点所有资产
2. 专项盘点：指定分类盘点
3. 抽样盘点：随机抽取盘点

*盘点流程*:
```
创建计划 → 生成明细 → 开始盘点 → 执行盘点 → 记录结果 → 完成盘点
   ↓          ↓          ↓          ↓          ↓          ↓
  待开始      待盘点      进行中      进行中      进行中      已完成
```

*主要类*:
- AssetInventoryController
- AssetInventoryService
- AssetInventory (Entity)
- AssetInventoryDetail (Entity)

**模块6: 报修管理模块**

*模块职责*:
- 处理资产报修流程
- 跟踪维修进度
- 记录维修历史

*报修流程*:
```
提交申请 → 待审批 → 审批通过 → 维修中 → 维修完成
   ↓         ↓         ↓         ↓         ↓
 待审批    审批中     已审批     维修中     已完成
```

*主要类*:
- AssetRepairController
- AssetRepairService
- AssetRepair (Entity)

### 3.3 数据库设计

#### 3.3.1 数据库概述

系统数据库采用MySQL 8.0，包含15张主要数据表，存储引擎为InnoDB，字符集为utf8mb4。

**表分类**:
- 系统管理表：5张（用户、角色、部门、菜单、关联表）
- 资产管理表：4张（资产信息、分类、流转记录、编号序列）
- 采购管理表：2张（采购单、采购明细）
- 生命周期表：1张（生命周期记录）
- 盘点管理表：2张（盘点计划、盘点明细）
- 报修管理表：1张（报修记录）

#### 3.3.2 核心表设计

**表1: sys_user (用户表)**

| 字段名 | 类型 | 约束 | 说明 |
|--------|------|------|------|
| id | BIGINT | PK, AUTO_INCREMENT | 用户ID |
| username | VARCHAR(50) | NOT NULL, UNIQUE | 用户名 |
| password | VARCHAR(100) | NOT NULL | 密码(BCrypt加密) |
| nickname | VARCHAR(50) | | 昵称 |
| email | VARCHAR(100) | | 邮箱 |
| phone | VARCHAR(20) | | 手机号 |
| avatar | VARCHAR(255) | | 头像URL |
| status | TINYINT | NOT NULL, DEFAULT 1 | 状态：0-禁用，1-正常 |
| deleted | TINYINT | NOT NULL, DEFAULT 0 | 删除标记 |
| create_time | DATETIME | NOT NULL | 创建时间 |
| update_time | DATETIME | NOT NULL | 更新时间 |

**索引**:
- PRIMARY KEY: id
- UNIQUE KEY: username

**表2: sys_role (角色表)**

| 字段名 | 类型 | 约束 | 说明 |
|--------|------|------|------|
| id | BIGINT | PK, AUTO_INCREMENT | 角色ID |
| role_code | VARCHAR(50) | NOT NULL, UNIQUE | 角色编码 |
| role_name | VARCHAR(50) | NOT NULL | 角色名称 |
| status | TINYINT | NOT NULL, DEFAULT 1 | 状态 |
| remark | VARCHAR(200) | | 备注 |
| deleted | TINYINT | NOT NULL, DEFAULT 0 | 删除标记 |
| create_time | DATETIME | NOT NULL | 创建时间 |
| update_time | DATETIME | NOT NULL | 更新时间 |

**表3: sys_menu (菜单权限表)**

| 字段名 | 类型 | 约束 | 说明 |
|--------|------|------|------|
| id | BIGINT | PK, AUTO_INCREMENT | 菜单ID |
| parent_id | BIGINT | | 父菜单ID |
| menu_name | VARCHAR(50) | NOT NULL | 菜单名称 |
| menu_type | VARCHAR(10) | NOT NULL | 类型：DIR/MENU/BUTTON |
| permission_code | VARCHAR(100) | | 权限标识 |
| path | VARCHAR(200) | | 路由路径 |
| component | VARCHAR(200) | | 组件路径 |
| icon | VARCHAR(50) | | 图标 |
| sort_order | INT | DEFAULT 0 | 排序 |
| status | TINYINT | DEFAULT 1 | 状态 |
| deleted | TINYINT | DEFAULT 0 | 删除标记 |
| create_time | DATETIME | NOT NULL | 创建时间 |
| update_time | DATETIME | NOT NULL | 更新时间 |

**表4: asset_info (资产信息表)**

| 字段名 | 类型 | 约束 | 说明 |
|--------|------|------|------|
| id | BIGINT | PK, AUTO_INCREMENT | 资产ID |
| asset_number | VARCHAR(50) | NOT NULL, UNIQUE | 资产编号 |
| asset_name | VARCHAR(100) | NOT NULL | 资产名称 |
| category_id | BIGINT | | 分类ID |
| model | VARCHAR(100) | | 型号 |
| specification | VARCHAR(200) | | 规格 |
| purchase_date | DATE | | 采购日期 |
| purchase_price | DECIMAL(15,2) | | 采购价格 |
| supplier | VARCHAR(100) | | 供应商 |
| department_id | BIGINT | | 使用部门ID |
| responsible_person | VARCHAR(50) | | 责任人 |
| location | VARCHAR(100) | | 存放位置 |
| status | TINYINT | DEFAULT 1 | 资产状态 |
| lifecycle_stage | TINYINT | | 生命周期阶段 |
| remark | VARCHAR(500) | | 备注 |
| deleted | TINYINT | DEFAULT 0 | 删除标记 |
| create_time | DATETIME | NOT NULL | 创建时间 |
| update_time | DATETIME | NOT NULL | 更新时间 |

**索引**:
- PRIMARY KEY: id
- UNIQUE KEY: asset_number
- INDEX: category_id, department_id, status

**表5: asset_category (资产分类表)**

| 字段名 | 类型 | 约束 | 说明 |
|--------|------|------|------|
| id | BIGINT | PK, AUTO_INCREMENT | 分类ID |
| parent_id | BIGINT | | 父分类ID |
| category_name | VARCHAR(50) | NOT NULL | 分类名称 |
| category_code | VARCHAR(50) | UNIQUE | 分类编码 |
| sort_order | INT | DEFAULT 0 | 排序 |
| remark | VARCHAR(200) | | 备注 |
| deleted | TINYINT | DEFAULT 0 | 删除标记 |
| create_time | DATETIME | NOT NULL | 创建时间 |
| update_time | DATETIME | NOT NULL | 更新时间 |

**表6: asset_record (资产流转记录表)**

| 字段名 | 类型 | 约束 | 说明 |
|--------|------|------|------|
| id | BIGINT | PK, AUTO_INCREMENT | 记录ID |
| asset_id | BIGINT | NOT NULL | 资产ID |
| record_type | VARCHAR(20) | NOT NULL | 流转类型 |
| from_department_id | BIGINT | | 原部门ID |
| to_department_id | BIGINT | | 目标部门ID |
| from_person | VARCHAR(50) | | 原责任人 |
| to_person | VARCHAR(50) | | 新责任人 |
| reason | VARCHAR(500) | | 流转原因 |
| operator | VARCHAR(50) | | 操作人 |
| operate_time | DATETIME | NOT NULL | 操作时间 |
| deleted | TINYINT | DEFAULT 0 | 删除标记 |
| create_time | DATETIME | NOT NULL | 创建时间 |

**索引**:
- PRIMARY KEY: id
- INDEX: asset_id, operate_time

**表7: asset_lifecycle (生命周期记录表)**

| 字段名 | 类型 | 约束 | 说明 |
|--------|------|------|------|
| id | BIGINT | PK, AUTO_INCREMENT | 记录ID |
| asset_id | BIGINT | NOT NULL | 资产ID |
| previous_stage | TINYINT | | 变更前阶段 |
| current_stage | TINYINT | NOT NULL | 当前阶段 |
| change_reason | VARCHAR(500) | | 变更原因 |
| operator | VARCHAR(50) | | 操作人 |
| operate_time | DATETIME | NOT NULL | 操作时间 |
| from_department_id | BIGINT | | 变更前部门 |
| to_department_id | BIGINT | | 变更后部门 |
| from_person | VARCHAR(50) | | 变更前责任人 |
| to_person | VARCHAR(50) | | 变更后责任人 |
| deleted | TINYINT | DEFAULT 0 | 删除标记 |
| create_time | DATETIME | NOT NULL | 创建时间 |

**表8: asset_purchase_order (采购单表)**

| 字段名 | 类型 | 约束 | 说明 |
|--------|------|------|------|
| id | BIGINT | PK, AUTO_INCREMENT | 采购单ID |
| purchase_number | VARCHAR(50) | UNIQUE | 采购单号 |
| applicant_id | BIGINT | NOT NULL | 申请人ID |
| purchase_date | DATE | NOT NULL | 采购日期 |
| total_amount | DECIMAL(15,2) | | 总金额 |
| status | TINYINT | DEFAULT 1 | 状态 |
| remark | VARCHAR(500) | | 备注 |
| deleted | TINYINT | DEFAULT 0 | 删除标记 |
| create_time | DATETIME | NOT NULL | 创建时间 |
| update_time | DATETIME | NOT NULL | 更新时间 |

**表9: asset_inventory (盘点计划表)**

| 字段名 | 类型 | 约束 | 说明 |
|--------|------|------|------|
| id | BIGINT | PK, AUTO_INCREMENT | 盘点ID |
| inventory_number | VARCHAR(50) | UNIQUE | 盘点编号 |
| inventory_name | VARCHAR(100) | NOT NULL | 盘点名称 |
| inventory_type | TINYINT | NOT NULL | 盘点类型 |
| category_id | BIGINT | | 专项盘点分类 |
| sample_count | INT | | 抽样数量 |
| start_date | DATE | | 开始日期 |
| end_date | DATE | | 结束日期 |
| creator | VARCHAR(50) | | 创建人 |
| status | TINYINT | DEFAULT 1 | 状态 |
| total_count | INT | DEFAULT 0 | 总数量 |
| normal_count | INT | DEFAULT 0 | 正常数量 |
| abnormal_count | INT | DEFAULT 0 | 异常数量 |
| deleted | TINYINT | DEFAULT 0 | 删除标记 |
| create_time | DATETIME | NOT NULL | 创建时间 |
| update_time | DATETIME | NOT NULL | 更新时间 |

**表10: asset_repair (报修记录表)**

| 字段名 | 类型 | 约束 | 说明 |
|--------|------|------|------|
| id | BIGINT | PK, AUTO_INCREMENT | 报修ID |
| repair_number | VARCHAR(50) | UNIQUE | 报修单号 |
| asset_id | BIGINT | NOT NULL | 资产ID |
| repair_type | TINYINT | NOT NULL | 报修类型 |
| priority | TINYINT | DEFAULT 2 | 优先级 |
| fault_description | VARCHAR(500) | NOT NULL | 故障描述 |
| reporter | VARCHAR(50) | | 报修人 |
| approver | VARCHAR(50) | | 审批人 |
| maintainer | VARCHAR(50) | | 维修人 |
| status | TINYINT | DEFAULT 1 | 状态 |
| deleted | TINYINT | DEFAULT 0 | 删除标记 |
| create_time | DATETIME | NOT NULL | 创建时间 |
| update_time | DATETIME | NOT NULL | 更新时间 |

#### 3.3.3 数据库关系图

```
sys_user ←──┐
     │      │
     │      │ N:M
     ↓      │
sys_user_role → sys_role ←──┐
                    │        │
                    │        │ N:M
                    ↓        │
              sys_role_menu → sys_menu
                              
asset_category (树形结构)
     │ 1:N
     ↓
asset_info ←──── asset_record
     │              (流转记录)
     │ 1:N
     ├─→ asset_lifecycle (生命周期)
     │
     ├─→ asset_inventory_detail (盘点明细)
     │
     └─→ asset_repair (报修记录)

asset_purchase_order
     │ 1:N
     ↓
asset_purchase_detail
     │
     └─→ asset_info (关联采购生成的资产)
```

#### 3.3.4 数据库设计原则

1. **规范化设计**：
   - 遵循第三范式(3NF)，减少数据冗余
   - 合理使用反范式化，平衡性能和存储

2. **命名规范**：
   - 表名：小写+下划线，如asset_info
   - 字段名：小写+下划线，如create_time
   - 索引名：idx_表名_字段名

3. **数据类型选择**：
   - 主键：BIGINT，预留足够空间
   - 金额：DECIMAL(15,2)，避免精度丢失
   - 时间：DATETIME，精确到秒
   - 状态：TINYINT，节省空间

4. **索引设计**：
   - 主键索引：所有表都有自增主键
   - 唯一索引：业务唯一字段（编号、用户名等）
   - 普通索引：高频查询字段（外键、状态等）
   - 组合索引：多字段联合查询

5. **软删除设计**：
   - 使用deleted字段标记删除
   - 0-未删除，1-已删除
   - 保留历史数据，便于审计和恢复

6. **时间戳设计**：
   - create_time：创建时间，不可更新
   - update_time：更新时间，自动更新
   - 使用MyBatis Plus自动填充

### 3.4 接口设计

#### 3.4.1 RESTful API设计规范

系统API遵循RESTful设计风格：

**URL设计规范**:
```
/api/{module}/{resource}[/{id}][/{action}]

示例：
- GET /api/asset/info              # 查询资产列表
- GET /api/asset/info/1            # 查询ID为1的资产
- POST /api/asset/info             # 创建资产
- PUT /api/asset/info/1            # 更新ID为1的资产
- DELETE /api/asset/info/1         # 删除ID为1的资产
- POST /api/asset/record/allocate  # 资产分配操作
```

**HTTP方法语义**:
- GET：查询资源，幂等操作
- POST：创建资源或非幂等操作
- PUT：完整更新资源
- PATCH：部分更新资源
- DELETE：删除资源

**统一响应格式**:
```json
{
  "code": 200,
  "message": "操作成功",
  "data": {}
}
```

**状态码定义**:
- 200：成功
- 400：参数错误
- 401：未认证
- 403：权限不足
- 404：资源不存在
- 500：服务器错误

#### 3.4.2 核心API接口列表

**认证接口**:
```
POST   /api/auth/login              # 用户登录
POST   /api/auth/logout             # 用户登出
POST   /api/auth/refresh            # 刷新Token
GET    /api/auth/current            # 获取当前用户信息
```

**用户管理接口**:
```
GET    /api/user                    # 查询用户列表
GET    /api/user/{id}               # 查询用户详情
POST   /api/user                    # 创建用户
PUT    /api/user/{id}               # 更新用户
DELETE /api/user/{id}               # 删除用户
PUT    /api/user/{id}/status        # 启用/禁用用户
POST   /api/user/{id}/reset-password # 重置密码
POST   /api/user/{id}/assign-roles  # 分配角色
```

**资产管理接口**:
```
GET    /api/asset/info              # 查询资产列表
GET    /api/asset/info/{id}         # 查询资产详情
POST   /api/asset/info              # 创建资产
PUT    /api/asset/info/{id}         # 更新资产
DELETE /api/asset/info/{id}         # 删除资产
POST   /api/asset/info/import       # 批量导入
GET    /api/asset/info/export       # 批量导出
GET    /api/asset/category/tree     # 获取分类树
```

**资产流转接口**:
```
POST   /api/asset/record/in         # 资产入库
POST   /api/asset/record/allocate   # 资产分配
POST   /api/asset/record/transfer   # 资产调拨
POST   /api/asset/record/return     # 资产归还
POST   /api/asset/record/repair     # 资产送修
POST   /api/asset/record/scrap      # 资产报废
GET    /api/asset/record            # 查询流转记录
GET    /api/asset/record/history/{assetId} # 查询资产流转历史
```

**采购管理接口**:
```
GET    /api/purchase                # 查询采购单列表
GET    /api/purchase/{id}           # 查询采购单详情
POST   /api/purchase                # 创建采购单
PUT    /api/purchase/{id}           # 更新采购单
DELETE /api/purchase/{id}           # 删除采购单
POST   /api/purchase/{id}/cancel    # 取消采购单
GET    /api/purchase/statistics     # 采购统计
```

**盘点管理接口**:
```
GET    /api/inventory               # 查询盘点计划列表
GET    /api/inventory/{id}          # 查询盘点详情
POST   /api/inventory               # 创建盘点计划
POST   /api/inventory/{id}/start    # 开始盘点
POST   /api/inventory/{id}/execute  # 执行盘点
POST   /api/inventory/{id}/complete # 完成盘点
GET    /api/inventory/{id}/details  # 查询盘点明细（分页）
```

**报修管理接口**:
```
GET    /api/repair                  # 查询报修列表
GET    /api/repair/{id}             # 查询报修详情
POST   /api/repair                  # 创建报修
POST   /api/repair/{id}/approve     # 审批报修
POST   /api/repair/{id}/start       # 开始维修
POST   /api/repair/{id}/complete    # 完成维修
```

**仪表盘接口**:
```
GET    /api/dashboard/statistics    # 获取统计数据
GET    /api/dashboard/distribution  # 获取分布数据
GET    /api/dashboard/trend         # 获取趋势数据
```

#### 3.4.3 接口鉴权设计

**JWT Token机制**:
1. 用户登录成功后，服务器生成JWT Token
2. Token包含用户信息和权限信息
3. 客户端在请求头中携带Token：`Authorization: Bearer <token>`
4. 服务器验证Token有效性和权限

**Token结构**:
```json
{
  "header": {
    "alg": "HS256",
    "typ": "JWT"
  },
  "payload": {
    "userId": 1,
    "username": "admin",
    "exp": 1704067200
  },
  "signature": "..."
}
```

**权限校验流程**:
1. JwtAuthenticationFilter拦截请求
2. 提取并验证Token
3. 解析Token获取用户信息
4. 加载用户权限集合
5. 设置Spring Security上下文
6. @PreAuthorize注解校验权限
7. 通过则执行业务逻辑，否则返回403

### 3.5 页面设计

#### 3.5.1 页面布局设计

系统采用经典的后台管理系统布局：

```
┌───────────────────────────────────────────────────────────┐
│                      顶部导航栏                              │
│  Logo | 系统名称              用户信息  消息  退出            │
└───────────────────────────────────────────────────────────┘
┌─────────────┬─────────────────────────────────────────────┐
│             │                                             │
│             │                                             │
│   侧边导航    │              主内容区                        │
│             │                                             │
│  • 仪表盘    │         ┌──────────────────┐              │
│  • 系统管理  │         │  面包屑导航         │              │
│  • 资产管理  │         └──────────────────┘              │
│  • 采购管理  │                                             │
│  • 生命周期  │         ┌──────────────────┐              │
│  • 盘点管理  │         │                  │              │
│  • 报修管理  │         │   页面内容区域    │              │
│  • 流转记录  │         │                  │              │
│             │         │                  │              │
│             │         └──────────────────┘              │
│             │                                             │
└─────────────┴─────────────────────────────────────────────┘
```

**布局特点**:
- 顶部导航栏：固定在顶部，显示系统信息和用户操作
- 侧边导航栏：可折叠，树形菜单结构
- 主内容区：动态加载页面内容，支持标签页切换
- 面包屑导航：显示当前位置，支持快速导航

#### 3.5.2 核心页面设计

**登录页面**:
- 简洁的登录表单
- 用户名、密码输入
- 记住密码功能
- 登录按钮和错误提示

**仪表盘页面**:
- 顶部数据卡片：总资产、在用、闲置、报废
- 中间图表区：
  - 资产按部门分布（饼图）
  - 资产按分类分布（柱状图）
  - 资产数量趋势（折线图）
- 底部快捷操作区

**资产列表页面**:
- 搜索筛选区：
  - 资产编号、名称、分类
  - 状态、部门筛选
  - 日期范围选择
- 操作按钮区：
  - 新增资产、批量导入、批量导出
- 数据表格区：
  - 显示资产基本信息
  - 操作列：查看、编辑、删除、流转
- 分页组件

**资产详情页面**:
- 基本信息卡片
- 采购信息卡片
- 使用信息卡片
- 折旧信息卡片
- 流转历史时间轴
- 生命周期时间轴

**资产流转页面**:
- 流转类型选择
- 资产选择器
- 流转信息表单
- 确认提交按钮

**盘点管理页面**:
- 盘点计划列表
- 创建盘点按钮
- 盘点类型选择（全面/专项/抽样）
- 盘点明细展示
- 盘点结果记录

#### 3.5.3 UI组件设计

**通用组件**:
- 表格组件：支持排序、筛选、分页
- 表单组件：支持验证、联动
- 对话框组件：确认、提示、表单弹窗
- 树形选择器：部门选择、分类选择
- 日期范围选择器
- 文件上传组件
- 图表组件：ECharts封装

**业务组件**:
- 资产选择器：支持搜索和批量选择
- 用户选择器：支持搜索和角色筛选
- 部门选择器：树形结构选择
- 权限树组件：菜单权限选择

#### 3.5.4 交互设计

**表单交互**:
- 实时验证：输入框失焦时验证
- 错误提示：在输入框下方显示
- 联动效果：分类选择后自动加载子分类
- 提交反馈：显示加载状态，成功/失败提示

**表格交互**:
- 行选择：支持单选和多选
- 排序：点击列标题排序
- 筛选：列筛选下拉框
- 行操作：悬浮显示操作按钮

**导航交互**:
- 菜单折叠：点击切换侧边栏展开/折叠
- 面包屑：点击快速跳转
- 标签页：支持关闭和切换

---

## 第四章 系统实现

### 4.1 后端实现

#### 4.1.1 项目结构


```
src/main/java/com/eams/
├── EamsApplication.java           # 启动类
├── aop/                            # AOP切面
│   ├── OperationLog.java           # 操作日志注解
│   └── OperationLogAspect.java     # 操作日志切面
├── common/                         # 通用模块
│   ├── constant/                   # 常量定义
│   ├── exception/                  # 异常定义
│   └── result/                     # 统一返回结果
├── config/                         # 配置类
│   ├── CorsConfig.java             # 跨域配置
│   ├── MyBatisPlusConfig.java      # MyBatis Plus配置
│   ├── RedisConfig.java            # Redis配置
│   ├── SecurityConfig.java         # Security配置
│   └── SwaggerConfig.java          # Swagger配置
├── security/                       # 安全模块
│   ├── JwtUtil.java                # JWT工具类
│   ├── JwtAuthenticationFilter.java # JWT过滤器
│   └── UserDetailsServiceImpl.java  # 用户详情服务
├── system/                         # 系统管理模块
│   ├── controller/                 # 控制器
│   ├── service/                    # 服务层
│   ├── mapper/                     # 数据访问层
│   ├── entity/                     # 实体类
│   ├── dto/                        # 数据传输对象
│   └── vo/                         # 视图对象
├── asset/                          # 资产管理模块
├── purchase/                       # 采购管理模块
├── lifecycle/                      # 生命周期模块
├── dashboard/                      # 仪表盘模块
└── ...                             # 其他模块
```

#### 4.1.2 核心代码实现

**认证实现 (UserDetailsServiceImpl.java)**:
```java
@Service
public class UserDetailsServiceImpl implements UserDetailsService {
    
    @Autowired
    private UserMapper userMapper;
    
    @Autowired
    private PermissionService permissionService;
    
    @Override
    public UserDetails loadUserByUsername(String username) {
        // 查询用户
        User user = userMapper.selectOne(
            new QueryWrapper<User>().eq("username", username)
        );
        
        if (user == null) {
            throw new UsernameNotFoundException("用户不存在");
        }
        
        // 加载用户权限
        Set<String> permissions = permissionService.getUserPermissions(user.getId());
        
        // 构建UserDetails
        return new UserDetailsImpl(user, permissions);
    }
}
```

**JWT工具类实现 (JwtUtil.java)**:
```java
@Component
public class JwtUtil {
    
    @Value("${jwt.secret}")
    private String secret;
    
    @Value("${jwt.expiration}")
    private Long expiration;
    
    // 生成Token
    public String generateToken(String username) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expiration * 1000);
        
        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(SignatureAlgorithm.HS256, secret)
                .compact();
    }
    
    // 验证Token
    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(secret).parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
    
    // 从Token中获取用户名
    public String getUsernameFromToken(String token) {
        Claims claims = Jwts.parser()
                .setSigningKey(secret)
                .parseClaimsJws(token)
                .getBody();
        return claims.getSubject();
    }
}
```

**统一异常处理 (GlobalExceptionHandler.java)**:
```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    // 业务异常
    @ExceptionHandler(BusinessException.class)
    public Result<Void> handleBusinessException(BusinessException e) {
        log.error("业务异常：{}", e.getMessage());
        return Result.error(e.getCode(), e.getMessage());
    }
    
    // 参数校验异常
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Result<Void> handleValidationException(MethodArgumentNotValidException e) {
        String message = e.getBindingResult().getFieldError().getDefaultMessage();
        return Result.error(400, message);
    }
    
    // 权限不足异常
    @ExceptionHandler(AccessDeniedException.class)
    public Result<Void> handleAccessDeniedException(AccessDeniedException e) {
        return Result.error(403, "权限不足");
    }
    
    // 其他异常
    @ExceptionHandler(Exception.class)
    public Result<Void> handleException(Exception e) {
        log.error("系统异常", e);
        return Result.error(500, "系统异常");
    }
}
```

**Service层实现示例 (AssetInfoServiceImpl.java)**:
```java
@Service
@Transactional
public class AssetInfoServiceImpl implements AssetInfoService {
    
    @Autowired
    private AssetInfoMapper assetInfoMapper;
    
    @Autowired
    private AssetLifecycleService lifecycleService;
    
    @Override
    public Long createAsset(AssetCreateRequest request) {
        // 1. 生成资产编号
        String assetNumber = generateAssetNumber();
        
        // 2. 创建资产实体
        AssetInfo asset = new AssetInfo();
        BeanUtils.copyProperties(request, asset);
        asset.setAssetNumber(assetNumber);
        asset.setStatus(AssetStatus.IDLE.getCode());
        
        // 3. 保存资产
        assetInfoMapper.insert(asset);
        
        // 4. 创建生命周期记录
        lifecycleService.createLifecycle(
            asset.getId(),
            LifecycleStage.PURCHASE,
            "资产采购入库"
        );
        
        return asset.getId();
    }
    
    @Override
    public IPage<AssetVO> listAssets(AssetQueryRequest request) {
        // 1. 构建查询条件
        QueryWrapper<AssetInfo> queryWrapper = new QueryWrapper<>();
        if (StrUtil.isNotBlank(request.getAssetNumber())) {
            queryWrapper.like("asset_number", request.getAssetNumber());
        }
        if (request.getCategoryId() != null) {
            queryWrapper.eq("category_id", request.getCategoryId());
        }
        if (request.getStatus() != null) {
            queryWrapper.eq("status", request.getStatus());
        }
        
        // 2. 分页查询
        Page<AssetInfo> page = new Page<>(request.getPageNum(), request.getPageSize());
        IPage<AssetInfo> assetPage = assetInfoMapper.selectPage(page, queryWrapper);
        
        // 3. 转换为VO
        return assetPage.convert(this::convertToVO);
    }
    
    private AssetVO convertToVO(AssetInfo entity) {
        AssetVO vo = new AssetVO();
        BeanUtils.copyProperties(entity, vo);
        
        // 填充额外信息
        if (entity.getCategoryId() != null) {
            AssetCategory category = categoryMapper.selectById(entity.getCategoryId());
            vo.setCategoryName(category != null ? category.getCategoryName() : null);
        }
        
        return vo;
    }
}
```

#### 4.1.3 权限控制实现

**方法级权限控制**:
```java
@RestController
@RequestMapping("/user")
public class UserController {
    
    @PreAuthorize("hasAuthority('system:user:add')")
    @PostMapping
    public Result<Long> createUser(@RequestBody @Valid UserCreateRequest request) {
        Long userId = userService.createUser(request);
        return Result.success(userId);
    }
    
    @PreAuthorize("hasAuthority('system:user:edit')")
    @PutMapping("/{id}")
    public Result<Void> updateUser(@PathVariable Long id, 
                                    @RequestBody @Valid UserUpdateRequest request) {
        userService.updateUser(id, request);
        return Result.success();
    }
    
    @PreAuthorize("hasAuthority('system:user:delete')")
    @DeleteMapping("/{id}")
    public Result<Void> deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return Result.success();
    }
}
```

**权限加载实现**:
```java
@Service
public class PermissionServiceImpl implements PermissionService {
    
    @Autowired
    private UserRoleMapper userRoleMapper;
    
    @Autowired
    private RoleMenuMapper roleMenuMapper;
    
    @Autowired
    private MenuMapper menuMapper;
    
    @Override
    public Set<String> getUserPermissions(Long userId) {
        // 1. 查询用户角色ID列表
        List<Long> roleIds = userRoleMapper.selectRoleIdsByUserId(userId);
        
        if (CollectionUtils.isEmpty(roleIds)) {
            return Collections.emptySet();
        }
        
        // 2. 查询角色菜单ID列表
        List<Long> menuIds = roleMenuMapper.selectMenuIdsByRoleIds(roleIds);
        
        if (CollectionUtils.isEmpty(menuIds)) {
            return Collections.emptySet();
        }
        
        // 3. 查询菜单权限标识
        List<Menu> menus = menuMapper.selectBatchIds(menuIds);
        
        // 4. 过滤并收集权限标识
        return menus.stream()
                .map(Menu::getPermissionCode)
                .filter(StrUtil::isNotBlank)
                .collect(Collectors.toSet());
    }
}
```

### 4.2 前端实现

#### 4.2.1 项目结构

```
frontend/src/
├── api/                    # API接口封装
│   ├── auth.ts             # 认证接口
│   ├── user.ts             # 用户接口
│   ├── asset.ts            # 资产接口
│   └── ...
├── assets/                 # 静态资源
├── components/             # 公共组件
│   ├── AssetSelector.vue   # 资产选择器
│   ├── UserSelector.vue    # 用户选择器
│   └── ...
├── directives/             # 自定义指令
│   └── permission.ts       # 权限指令
├── layout/                 # 布局组件
│   ├── MainLayout.vue      # 主布局
│   ├── Header.vue          # 顶部导航
│   └── Sidebar.vue         # 侧边菜单
├── router/                 # 路由配置
│   └── index.ts
├── stores/                 # 状态管理
│   ├── user.ts             # 用户状态
│   └── permission.ts       # 权限状态
├── types/                  # TypeScript类型定义
│   ├── user.ts
│   ├── asset.ts
│   └── ...
├── utils/                  # 工具函数
│   ├── request.ts          # Axios封装
│   ├── auth.ts             # 认证工具
│   └── ...
├── views/                  # 页面组件
│   ├── Login.vue           # 登录页
│   ├── Dashboard.vue       # 仪表盘
│   ├── UserManagement.vue  # 用户管理
│   ├── AssetManagement.vue # 资产管理
│   └── ...
├── App.vue                 # 根组件
└── main.ts                 # 入口文件
```

#### 4.2.2 核心代码实现

**Axios封装 (utils/request.ts)**:
```typescript
import axios from 'axios'
import { ElMessage } from 'element-plus'
import { useUserStore } from '@/stores/user'

const request = axios.create({
  baseURL: '/api',
  timeout: 10000
})

// 请求拦截器
request.interceptors.request.use(
  config => {
    const userStore = useUserStore()
    const token = userStore.token
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`
    }
    return config
  },
  error => {
    return Promise.reject(error)
  }
)

// 响应拦截器
request.interceptors.response.use(
  response => {
    const res = response.data
    if (res.code !== 200) {
      ElMessage.error(res.message || '请求失败')
      return Promise.reject(new Error(res.message || '请求失败'))
    }
    return res.data
  },
  error => {
    if (error.response?.status === 401) {
      ElMessage.error('登录已过期，请重新登录')
      const userStore = useUserStore()
      userStore.logout()
    } else {
      ElMessage.error(error.message || '网络错误')
    }
    return Promise.reject(error)
  }
)

export default request
```

**用户状态管理 (stores/user.ts)**:
```typescript
import { defineStore } from 'pinia'
import { login, getCurrentUser } from '@/api/auth'
import type { LoginRequest, LoginResponse, UserInfo } from '@/types/user'

export const useUserStore = defineStore('user', {
  state: () => ({
    token: localStorage.getItem('token') || '',
    userInfo: null as UserInfo | null
  }),
  
  getters: {
    isLoggedIn: (state) => !!state.token
  },
  
  actions: {
    async login(loginRequest: LoginRequest) {
      const response: LoginResponse = await login(loginRequest)
      this.token = response.token
      this.userInfo = response.userInfo
      localStorage.setItem('token', response.token)
    },
    
    async fetchUserInfo() {
      const userInfo = await getCurrentUser()
      this.userInfo = userInfo
    },
    
    logout() {
      this.token = ''
      this.userInfo = null
      localStorage.removeItem('token')
    }
  }
})
```

**权限指令 (directives/permission.ts)**:
```typescript
import type { Directive } from 'vue'
import { usePermissionStore } from '@/stores/permission'

export const permission: Directive = {
  mounted(el, binding) {
    const { value } = binding
    const permissionStore = usePermissionStore()
    
    if (value && value instanceof Array && value.length > 0) {
      const hasPermission = value.some(permission => 
        permissionStore.hasPermission(permission)
      )
      
      if (!hasPermission) {
        el.parentNode?.removeChild(el)
      }
    }
  }
}
```

**资产列表组件 (views/AssetManagement.vue)**:
```vue
<template>
  <div class="asset-management">
    <!-- 搜索区 -->
    <el-form :model="queryForm" inline>
      <el-form-item label="资产编号">
        <el-input v-model="queryForm.assetNumber" placeholder="请输入资产编号" />
      </el-form-item>
      <el-form-item label="资产名称">
        <el-input v-model="queryForm.assetName" placeholder="请输入资产名称" />
      </el-form-item>
      <el-form-item>
        <el-button type="primary" @click="handleQuery">查询</el-button>
        <el-button @click="handleReset">重置</el-button>
      </el-form-item>
    </el-form>
    
    <!-- 操作按钮 -->
    <div class="toolbar">
      <el-button
        type="primary"
        v-permission="['asset:info:add']"
        @click="handleAdd"
      >
        新增资产
      </el-button>
      <el-button
        v-permission="['asset:info:import']"
        @click="handleImport"
      >
        批量导入
      </el-button>
      <el-button
        v-permission="['asset:info:export']"
        @click="handleExport"
      >
        批量导出
      </el-button>
    </div>
    
    <!-- 数据表格 -->
    <el-table :data="tableData" border>
      <el-table-column prop="assetNumber" label="资产编号" />
      <el-table-column prop="assetName" label="资产名称" />
      <el-table-column prop="categoryName" label="资产分类" />
      <el-table-column prop="departmentName" label="使用部门" />
      <el-table-column prop="statusText" label="状态" />
      <el-table-column label="操作" width="200">
        <template #default="{ row }">
          <el-button
            size="small"
            v-permission="['asset:info:view']"
            @click="handleView(row)"
          >
            查看
          </el-button>
          <el-button
            size="small"
            type="primary"
            v-permission="['asset:info:edit']"
            @click="handleEdit(row)"
          >
            编辑
          </el-button>
          <el-button
            size="small"
            type="danger"
            v-permission="['asset:info:delete']"
            @click="handleDelete(row)"
          >
            删除
          </el-button>
        </template>
      </el-table-column>
    </el-table>
    
    <!-- 分页 -->
    <el-pagination
      v-model:current-page="pagination.current"
      v-model:page-size="pagination.pageSize"
      :total="pagination.total"
      @current-change="fetchAssetList"
      @size-change="fetchAssetList"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { listAssets, deleteAsset } from '@/api/asset'
import type { Asset, AssetQueryRequest } from '@/types/asset'
import { ElMessage, ElMessageBox } from 'element-plus'

// 查询表单
const queryForm = ref<AssetQueryRequest>({
  assetNumber: '',
  assetName: ''
})

// 表格数据
const tableData = ref<Asset[]>([])

// 分页
const pagination = ref({
  current: 1,
  pageSize: 10,
  total: 0
})

// 查询资产列表
const fetchAssetList = async () => {
  const response = await listAssets({
    ...queryForm.value,
    pageNum: pagination.value.current,
    pageSize: pagination.value.pageSize
  })
  
  tableData.value = response.records
  pagination.value.total = response.total
}

// 查询
const handleQuery = () => {
  pagination.value.current = 1
  fetchAssetList()
}

// 重置
const handleReset = () => {
  queryForm.value = {
    assetNumber: '',
    assetName: ''
  }
  handleQuery()
}

// 新增
const handleAdd = () => {
  // 打开新增对话框
}

// 编辑
const handleEdit = (row: Asset) => {
  // 打开编辑对话框
}

// 删除
const handleDelete = async (row: Asset) => {
  await ElMessageBox.confirm('确认删除该资产吗？', '提示', {
    confirmButtonText: '确定',
    cancelButtonText: '取消',
    type: 'warning'
  })
  
  await deleteAsset(row.id)
  ElMessage.success('删除成功')
  fetchAssetList()
}

onMounted(() => {
  fetchAssetList()
})
</script>
```

### 4.3 关键技术实现

#### 4.3.1 资产编号自动生成

资产编号规则：`AS + 年份(4位) + 月份(2位) + 流水号(6位)`
例如：AS202401000001

**实现方式**:
```java
@Service
public class AssetNumberService {
    
    @Autowired
    private AssetNumberSequenceMapper sequenceMapper;
    
    @Transactional
    public synchronized String generateAssetNumber() {
        String prefix = "AS" + DateUtil.format(new Date(), "yyyyMM");
        
        // 查询或创建序列记录
        AssetNumberSequence sequence = sequenceMapper.selectByPrefix(prefix);
        
        if (sequence == null) {
            sequence = new AssetNumberSequence();
            sequence.setPrefix(prefix);
            sequence.setCurrentValue(1);
            sequenceMapper.insert(sequence);
        } else {
            sequence.setCurrentValue(sequence.getCurrentValue() + 1);
            sequenceMapper.updateById(sequence);
        }
        
        // 格式化编号
        String number = String.format("%06d", sequence.getCurrentValue());
        return prefix + number;
    }
}
```

#### 4.3.2 折旧计算实现

**折旧计算服务**:
```java
@Service
public class DepreciationService {
    
    private static final BigDecimal RESIDUAL_RATE = new BigDecimal("0.05"); // 残值率5%
    private static final int USEFUL_LIFE_MONTHS = 60; // 使用年限60个月
    
    public DepreciationInfo calculateDepreciation(AssetInfo asset, LocalDate targetDate) {
        BigDecimal purchasePrice = asset.getPurchasePrice();
        LocalDate purchaseDate = asset.getPurchaseDate();
        
        // 计算已使用月数
        long usedMonths = ChronoUnit.MONTHS.between(purchaseDate, targetDate);
        if (usedMonths < 0) usedMonths = 0;
        if (usedMonths > USEFUL_LIFE_MONTHS) usedMonths = USEFUL_LIFE_MONTHS;
        
        // 计算残值
        BigDecimal residualValue = purchasePrice.multiply(RESIDUAL_RATE)
                .setScale(2, RoundingMode.HALF_UP);
        
        // 计算月折旧额
        BigDecimal monthlyDepreciation = purchasePrice.subtract(residualValue)
                .divide(new BigDecimal(USEFUL_LIFE_MONTHS), 2, RoundingMode.HALF_UP);
        
        // 计算累计折旧
        BigDecimal accumulatedDepreciation = monthlyDepreciation
                .multiply(new BigDecimal(usedMonths))
                .setScale(2, RoundingMode.HALF_UP);
        
        // 计算净值
        BigDecimal netValue = purchasePrice.subtract(accumulatedDepreciation)
                .setScale(2, RoundingMode.HALF_UP);
        
        // 构建返回对象
        DepreciationInfo info = new DepreciationInfo();
        info.setPurchasePrice(purchasePrice);
        info.setResidualValue(residualValue);
        info.setMonthlyDepreciation(monthlyDepreciation);
        info.setAccumulatedDepreciation(accumulatedDepreciation);
        info.setNetValue(netValue);
        info.setUsedMonths((int) usedMonths);
        
        return info;
    }
}
```

#### 4.3.3 盘点明细分页查询

**分页查询实现**:
```java
@Service
public class AssetInventoryServiceImpl implements AssetInventoryService {
    
    @Override
    public IPage<InventoryDetailVO> getInventoryDetails(Long inventoryId, int pageNum, int pageSize) {
        Page<AssetInventoryDetail> page = new Page<>(pageNum, pageSize);
        
        QueryWrapper<AssetInventoryDetail> wrapper = new QueryWrapper<>();
        wrapper.eq("inventory_id", inventoryId)
               .orderByAsc("id");
        
        IPage<AssetInventoryDetail> detailPage = inventoryDetailMapper.selectPage(page, wrapper);
        
        // 转换为VO
        return detailPage.convert(detail -> {
            InventoryDetailVO vo = new InventoryDetailVO();
            BeanUtils.copyProperties(detail, vo);
            
            // 填充资产信息
            AssetInfo asset = assetInfoMapper.selectById(detail.getAssetId());
            if (asset != null) {
                vo.setAssetNumber(asset.getAssetNumber());
                vo.setAssetName(asset.getAssetName());
            }
            
            return vo;
        });
    }
}
```

#### 4.3.4 ECharts图表实现

**仪表盘图表组件**:
```vue
<template>
  <div ref="chartRef" style="width: 100%; height: 400px;"></div>
</template>

<script setup lang="ts">
import { ref, onMounted, watch } from 'vue'
import * as echarts from 'echarts'

interface ChartData {
  name: string
  value: number
}

const props = defineProps<{
  data: ChartData[]
}>()

const chartRef = ref<HTMLDivElement>()
let chartInstance: echarts.ECharts | null = null

const initChart = () => {
  if (!chartRef.value) return
  
  chartInstance = echarts.init(chartRef.value)
  
  const option = {
    title: {
      text: '资产按部门分布',
      left: 'center'
    },
    tooltip: {
      trigger: 'item',
      formatter: '{a} <br/>{b}: {c} ({d}%)'
    },
    legend: {
      orient: 'vertical',
      left: 'left'
    },
    series: [
      {
        name: '资产数量',
        type: 'pie',
        radius: '50%',
        data: props.data,
        emphasis: {
          itemStyle: {
            shadowBlur: 10,
            shadowOffsetX: 0,
            shadowColor: 'rgba(0, 0, 0, 0.5)'
          }
        }
      }
    ]
  }
  
  chartInstance.setOption(option)
}

watch(() => props.data, () => {
  if (chartInstance) {
    chartInstance.setOption({
      series: [{ data: props.data }]
    })
  }
}, { deep: true })

onMounted(() => {
  initChart()
  
  window.addEventListener('resize', () => {
    chartInstance?.resize()
  })
})
</script>
```

---

## 第五章 系统测试与部署

### 5.1 系统测试

#### 5.1.1 测试策略

系统测试采用分层测试策略：
1. **单元测试**：测试单个方法和函数
2. **集成测试**：测试模块间协作
3. **功能测试**：测试完整业务流程
4. **性能测试**：测试系统性能指标
5. **安全测试**：测试安全防护机制

#### 5.1.2 测试用例

**用户登录测试**:
- 正常登录：输入正确的用户名和密码
- 错误密码：输入错误的密码
- 不存在的用户：输入不存在的用户名
- 禁用用户：登录已禁用的用户
- Token有效性：验证Token过期后需重新登录

**资产管理测试**:
- 创建资产：输入完整的资产信息
- 编辑资产：修改资产信息
- 删除资产：删除未使用的资产
- 资产查询：按编号、名称、分类查询
- 批量导入：导入Excel文件
- 批量导出：导出资产列表

**权限控制测试**:
- 菜单权限：无权限的菜单不显示
- 按钮权限：无权限的按钮不显示
- 接口权限：无权限的接口返回403
- 角色切换：切换角色后权限生效

### 5.2 系统部署

#### 5.2.1 部署环境准备

**服务器要求**:
- 操作系统：CentOS 7+ / Ubuntu 20.04+
- CPU：4核以上
- 内存：8GB以上
- 硬盘：100GB以上

**软件安装**:
```bash
# 安装Java 17
sudo yum install java-17-openjdk

# 安装MySQL 8.0
sudo yum install mysql-server

# 安装Redis
sudo yum install redis

# 安装Nginx
sudo yum install nginx
```

#### 5.2.2 数据库初始化

```bash
# 登录MySQL
mysql -u root -p

# 创建数据库
CREATE DATABASE eams DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

# 导入SQL脚本
mysql -u root -p eams < /path/to/init.sql
mysql -u root -p eams < /path/to/rbac_system.sql
```

#### 5.2.3 后端部署

**编译打包**:
```bash
# 进入项目目录
cd /path/to/eams-backend

# Maven打包
mvn clean package -DskipTests

# 生成jar文件
target/eams-backend-1.0.0.jar
```

**启动服务**:
```bash
# 直接启动
java -jar eams-backend-1.0.0.jar

# 后台启动
nohup java -jar eams-backend-1.0.0.jar > app.log 2>&1 &

# 使用systemd管理
sudo vim /etc/systemd/system/eams.service

[Unit]
Description=EAMS Backend Service
After=network.target

[Service]
Type=simple
User=eams
ExecStart=/usr/bin/java -jar /opt/eams/eams-backend-1.0.0.jar
Restart=on-failure

[Install]
WantedBy=multi-user.target

# 启动服务
sudo systemctl start eams
sudo systemctl enable eams
```

#### 5.2.4 前端部署

**编译打包**:
```bash
# 进入前端目录
cd /path/to/frontend

# 安装依赖
npm install

# 构建生产版本
npm run build

# 生成dist目录
dist/
```

**Nginx配置**:
```nginx
server {
    listen 80;
    server_name eams.example.com;
    
    # 前端静态资源
    location / {
        root /var/www/eams/dist;
        try_files $uri $uri/ /index.html;
    }
    
    # API反向代理
    location /api/ {
        proxy_pass http://localhost:8080/api/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
```

#### 5.2.5 Docker部署

**Dockerfile (后端)**:
```dockerfile
FROM openjdk:17-jdk-slim
WORKDIR /app
COPY target/eams-backend-1.0.0.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
```

**docker-compose.yml**:
```yaml
version: '3.8'

services:
  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: eams
    volumes:
      - mysql-data:/var/lib/mysql
      - ./sql:/docker-entrypoint-initdb.d
    ports:
      - "3306:3306"
  
  redis:
    image: redis:6-alpine
    ports:
      - "6379:6379"
  
  backend:
    build: .
    depends_on:
      - mysql
      - redis
    environment:
      SPRING_DATASOURCE_URL: jdbc:mysql://mysql:3306/eams
      SPRING_REDIS_HOST: redis
    ports:
      - "8080:8080"
  
  frontend:
    image: nginx:alpine
    volumes:
      - ./frontend/dist:/usr/share/nginx/html
      - ./nginx.conf:/etc/nginx/conf.d/default.conf
    ports:
      - "80:80"
    depends_on:
      - backend

volumes:
  mysql-data:
```

**启动服务**:
```bash
docker-compose up -d
```

---

## 第六章 总结与展望

### 6.1 系统特色与创新

#### 6.1.1 技术特色

1. **前后端分离架构**
   - 前端使用Vue 3 + TypeScript，提供现代化的用户界面
   - 后端使用Spring Boot 3 + Java 17，提供稳定可靠的服务
   - 前后端完全解耦，可独立开发、部署和扩展

2. **完善的权限体系**
   - 实现RBAC权限模型，支持用户、角色、权限三级管理
   - 菜单、按钮、接口三端权限控制一致
   - 权限标识采用规范化命名，易于管理和维护

3. **全生命周期管理**
   - 从采购到报废的完整生命周期跟踪
   - 自动记录状态变更历史，数据可追溯
   - 支持生命周期可视化展示

4. **智能化盘点功能**
   - 支持全面、专项、抽样三种盘点方式
   - 盘点明细分页加载，提高大数据量处理能力
   - 自动标记异常资产，简化盘点流程

5. **精确的折旧计算**
   - 采用直线法自动计算折旧
   - 使用BigDecimal确保计算精度
   - 支持月度和年度账单生成

#### 6.1.2 业务创新

1. **数字化流转管理**
   - 入库、分配、调拨、归还、报废全流程数字化
   - 流转记录完整保存，便于审计追溯
   - 自动更新资产状态和生命周期

2. **可视化数据分析**
   - 丰富的统计图表展示
   - 多维度数据分析（部门、分类、时间）
   - 支持实时数据更新

3. **灵活的盘点策略**
   - 根据实际需求选择盘点方式
   - 专项盘点支持按分类盘点
   - 抽样盘点提高盘点效率

### 6.2 系统优势

1. **易用性强**
   - 界面美观友好，操作简单直观
   - 提供完整的帮助文档和操作说明
   - 错误提示明确，用户体验好

2. **扩展性好**
   - 模块化设计，便于功能扩展
   - RESTful API设计，便于系统集成
   - 支持二次开发和定制

3. **安全性高**
   - 多层次安全防护机制
   - JWT Token认证，无状态设计
   - 完善的权限控制体系

4. **性能优异**
   - 分页查询，减少数据传输量
   - Redis缓存，提高响应速度
   - 数据库索引优化，提升查询效率

5. **维护便捷**
   - 代码规范，可读性强
   - 完善的日志记录
   - 支持Docker部署，一键启动

### 6.3 存在的不足

1. **移动端支持**
   - 当前系统主要面向PC端
   - 移动端适配有待完善
   - 可考虑开发独立的移动应用

2. **高级分析功能**
   - 统计分析功能相对简单
   - 缺少预测分析和智能推荐
   - 报表功能可进一步丰富

3. **国际化支持**
   - 当前仅支持中文
   - 缺少多语言切换功能
   - 时区处理需要优化

4. **消息通知**
   - 系统通知功能较为基础
   - 缺少邮件、短信通知
   - WebSocket推送有待完善

### 6.4 未来展望

#### 6.4.1 功能扩展

1. **移动应用开发**
   - 开发Android/iOS移动应用
   - 支持移动端盘点扫码
   - 实现移动审批功能

2. **智能分析**
   - 引入机器学习算法
   - 资产使用趋势预测
   - 智能采购建议

3. **第三方集成**
   - 对接ERP系统
   - 对接财务系统
   - 对接OA系统

4. **报表增强**
   - 提供更多报表模板
   - 支持自定义报表
   - 支持更多导出格式

#### 6.4.2 技术升级

1. **微服务架构**
   - 拆分为多个微服务
   - 使用Spring Cloud进行服务治理
   - 提高系统可扩展性和容错性

2. **云原生改造**
   - 容器化部署
   - Kubernetes编排
   - 实现弹性伸缩

3. **大数据支持**
   - 引入大数据组件
   - 支持海量数据存储和分析
   - 实时数据处理

4. **人工智能应用**
   - 图像识别技术应用于资产盘点
   - 自然语言处理优化搜索功能
   - 智能问答助手

#### 6.4.3 性能优化

1. **数据库优化**
   - 读写分离
   - 分库分表
   - 数据归档策略

2. **缓存优化**
   - 多级缓存架构
   - 缓存预热策略
   - 缓存一致性保证

3. **前端优化**
   - 代码分割和懒加载
   - CDN加速
   - PWA支持

### 6.5 总结

企业资产管理系统(EAMS)是一个功能完善、架构合理、技术先进的资产管理平台。系统采用前后端分离架构，基于Spring Boot和Vue 3技术栈，实现了资产全生命周期管理、RBAC权限控制、智能盘点、折旧计算等核心功能。

系统具有以下特点：
- **技术先进**：采用最新的技术栈，性能优异
- **功能完善**：覆盖资产管理全流程
- **易于使用**：界面友好，操作便捷
- **安全可靠**：多层次安全防护，数据安全有保障
- **扩展性强**：模块化设计，便于二次开发

通过本系统的实施，可以有效提高企业资产管理效率，降低资产流失风险，优化资源配置，为企业数字化转型提供有力支持。未来，系统将持续优化和升级，引入更多先进技术，提供更强大的功能，更好地服务于企业资产管理需求。

---

## 参考文献

[1] Spring Boot官方文档. https://docs.spring.io/spring-boot/docs/current/reference/html/
[2] Vue 3官方文档. https://vuejs.org/
[3] MyBatis Plus官方文档. https://baomidou.com/
[4] Element Plus官方文档. https://element-plus.org/
[5] JWT官方规范. https://jwt.io/
[6] RESTful API设计指南. https://restfulapi.net/
[7] 阿里巴巴Java开发手册. https://github.com/alibaba/p3c
[8] 《Spring Boot实战》，汪云飞，电子工业出版社，2023年
[9] 《Vue.js设计与实现》，霍春阳，人民邮电出版社，2022年
[10] 《企业信息系统开发与实践》，王伟，清华大学出版社，2023年

---

## 附录

### 附录A 系统配置文件

**application.yml完整配置**:
```yaml
server:
  port: 8080
  servlet:
    context-path: /api

spring:
  application:
    name: eams-backend
  
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/eams?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai
    username: root
    password: your_password
  
  data:
    redis:
      host: localhost
      port: 6379
      password: 
      database: 0
  
  jackson:
    time-zone: GMT+8
    date-format: yyyy-MM-dd HH:mm:ss

mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
    map-underscore-to-camel-case: true
  type-aliases-package: com.eams.**.entity
  global-config:
    db-config:
      id-type: auto
      logic-delete-field: deleted

jwt:
  secret: eams-jwt-secret-key-2026
  expiration: 604800
  token-prefix: Bearer 
  header-name: Authorization

logging:
  level:
    root: INFO
    com.eams: DEBUG
```

### 附录B 数据库表清单

| 序号 | 表名 | 说明 | 记录数(示例) |
|------|------|------|-------------|
| 1 | sys_user | 用户表 | 50 |
| 2 | sys_role | 角色表 | 5 |
| 3 | sys_menu | 菜单权限表 | 80 |
| 4 | sys_user_role | 用户角色关联表 | 60 |
| 5 | sys_role_menu | 角色菜单关联表 | 200 |
| 6 | sys_department | 部门表 | 20 |
| 7 | asset_category | 资产分类表 | 30 |
| 8 | asset_info | 资产信息表 | 10000 |
| 9 | asset_record | 资产流转记录表 | 50000 |
| 10 | asset_lifecycle | 生命周期记录表 | 50000 |
| 11 | asset_purchase_order | 采购单表 | 500 |
| 12 | asset_purchase_detail | 采购明细表 | 2000 |
| 13 | asset_inventory | 盘点计划表 | 100 |
| 14 | asset_inventory_detail | 盘点明细表 | 50000 |
| 15 | asset_repair | 报修记录表 | 1000 |

### 附录C API接口清单

系统共提供80+个RESTful API接口，详细接口文档可通过Swagger UI访问：
http://localhost:8080/api/swagger-ui.html

### 附录D 部署检查清单

**部署前检查**:
- [ ] 服务器环境准备完成
- [ ] Java 17安装并配置
- [ ] MySQL 8.0安装并启动
- [ ] Redis安装并启动
- [ ] Nginx安装并配置
- [ ] 防火墙规则配置
- [ ] 域名解析配置

**数据库初始化**:
- [ ] 数据库创建完成
- [ ] init.sql执行完成
- [ ] rbac_system.sql执行完成
- [ ] 管理员账号初始化

**应用部署**:
- [ ] 后端jar包部署
- [ ] 前端dist文件部署
- [ ] 配置文件修改完成
- [ ] 服务启动成功
- [ ] 日志输出正常

**功能验证**:
- [ ] 登录功能正常
- [ ] 菜单显示正常
- [ ] 权限控制正常
- [ ] 数据查询正常
- [ ] 文件上传正常

---

**文档编写**: EAMS开发团队  
**文档版本**: V1.0  
**最后更新**: 2026年2月  
**联系方式**: eams@enterprise.com

---

*本文档是EAMS企业资产管理系统的完整技术文档，涵盖了系统的技术选型、需求分析、架构设计、详细设计、实现方案和部署指南。本文档旨在为系统的开发、维护、扩展和二次开发提供全面的技术参考。*

