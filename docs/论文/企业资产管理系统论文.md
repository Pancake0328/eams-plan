# 基于Spring Boot + Vue 3的企业资产管理系统的设计与实现

> **新疆大学本科毕业论文（设计）**

---

## 声明

本人郑重声明，本论文是在导师的指导下独立完成，除加注和致谢外，文中不包含他人所发表或撰写的成果。本人拥有自主知识产权，没有抄袭、剽窃他人成果，对于参考的文献已经加注并表示感谢。若有不实之处，本人愿意承担相关法律责任。

作者签名：\_\_\_\_\_\_\_\_\_\_\_\_  
签字日期：\_\_\_年\_\_\_月\_\_\_日

---

## 摘要

随着企业规模的不断扩大和信息化建设的持续深入，资产种类与数量呈现出爆发式增长态势，传统依赖人工登记、纸质台账的资产管理模式已难以满足现代企业对精细化、数字化管理的迫切需求。本文设计并实现了一套基于Spring Boot与Vue 3的企业资产管理系统（EAMS），旨在解决企业资产管理中存在的账实不符、流转不透明、盘点效率低下等核心痛点，实现对企业固定资产的全生命周期数字化管控。

系统采用前后端分离架构，后端基于Java 17与Spring Boot 3.1.5构建，整合Spring Security与JWT实现无状态认证，利用MyBatis Plus 3.5.7操作MySQL 8.0数据库，借助Redis 6.0提供缓存支持；前端基于Vue 3.4.0与TypeScript 5.3.3开发，结合Element Plus 2.5.0组件库、Pinia状态管理、Vue Router动态路由及ECharts数据可视化等技术构建现代化管理界面。

系统实现了五大核心功能模块：系统管理模块提供基于RBAC的用户、角色、部门、菜单权限全维度管控；资产管理模块支持多级分类、自动编号、资产台账及入库/分配/调拨/归还/报废/送修等完整流转操作；生命周期管理模块实现资产盘点（全面/抽样/专项）与报修管理（申请/审批/维修/完成）全流程管控；采购管理模块覆盖采购申请、审批与批量入库流程；统计分析模块通过ECharts多维图表直观展现资产状态分布、部门分布、趋势分析等核心业务指标。

经过系统测试验证，各功能模块运行稳定，接口响应时间均控制在500ms以内，并发用户支持达100人以上，满足中小型企业的实际业务需求。本系统的设计与实现对提升企业资产管理水平、降低资产流失风险、提高资源配置效率具有重要的实践意义。

**关键词：** 企业资产管理；Spring Boot；Vue 3；前后端分离；RBAC权限；生命周期管理

---

## ABSTRACT

With the continuous expansion of enterprise scale and the deepening of informatization construction, the types and quantities of assets have shown explosive growth. The traditional asset management mode relying on manual registration and paper-based ledgers can no longer meet the urgent needs of modern enterprises for refined and digital management. This paper designs and implements an Enterprise Asset Management System (EAMS) based on Spring Boot and Vue 3, aiming to solve core pain points such as account-physical discrepancies, opaque circulation, and low inventory efficiency in enterprise asset management, and to achieve full lifecycle digital control of enterprise fixed assets.

The system adopts a front-end and back-end separation architecture. The back-end is built on Java 17 and Spring Boot 3.1.5, integrating Spring Security and JWT for stateless authentication, using MyBatis Plus 3.5.7 to operate MySQL 8.0 database, and leveraging Redis 6.0 for caching support. The front-end is developed based on Vue 3.4.0 and TypeScript 5.3.3, combined with Element Plus 2.5.0 component library, Pinia state management, Vue Router dynamic routing, and ECharts data visualization.

The system implements five core functional modules: the system management module provides RBAC-based full-dimensional control of users, roles, departments, and menu permissions; the asset management module supports multi-level classification, automatic numbering, asset ledger, and complete circulation operations including warehousing, allocation, transfer, return, scrapping, and repair; the lifecycle management module implements full-process control of asset inventory (comprehensive/sampling/special) and repair management; the procurement management module covers procurement application, approval, and batch warehousing processes; and the statistical analysis module intuitively displays core business indicators such as asset status distribution, department distribution, and trend analysis through ECharts multi-dimensional charts.

After system testing and verification, all functional modules operate stably, interface response time is controlled within 500ms, and concurrent users support reaches more than 100, meeting the actual business needs of small and medium-sized enterprises.

**KEY WORDS:** Enterprise Asset Management; Spring Boot; Vue 3; Front-end and Back-end Separation; RBAC Permission; Lifecycle Management

---

## 目录

- [第1章 绪论](#第1章-绪论)
  - [1.1 研究背景及意义](#11-研究背景及意义)
  - [1.2 国内外研究现状](#12-国内外研究现状)
  - [1.3 论文主要内容](#13-论文主要内容)
  - [1.4 论文组织结构](#14-论文组织结构)
  - [1.5 本章小结](#15-本章小结)
- [第2章 相关技术基础](#第2章-相关技术基础)
- [第3章 系统分析](#第3章-系统分析)
- [第4章 系统设计](#第4章-系统设计)
- [第5章 系统实现](#第5章-系统实现)
- [第6章 系统测试](#第6章-系统测试)
- [第7章 总结与展望](#第7章-总结与展望)
- [参考文献](#参考文献)
- [致谢](#致谢)

---

# 第1章 绪论

## 1.1 研究背景及意义

随着智能互联网的高速发展，如今已经进入了高速数字化时代，高等教育事业也进入高速发展阶段，校园生活服务的便捷性与智能化水平成为衡量校园生活质量的重要指标，校区建设不断拓展，教学、科研及行政办公所需的资产数量呈爆发式增长，资产种类也日益多元化，涵盖教学仪器、科研设备、办公家具、基建设施等多个类别。据教育部统计，部分重点高校的资产总量已突破百亿元，且每年仍以10%-15%的速度递增。

在这样的背景下，传统的校园资产管理模式逐渐暴露诸多弊端。一方面，人工登记、纸质台账的管理方式效率低下，资产信息更新滞后，难以实现跨部门、跨校区的协同管理，导致"重采购、轻管理""账实不符"等问题普遍存在。例如，某高校在2023年资产清查中发现，有近30%的教学设备存在"有账无物"或"有物无账"的情况，其中价值超千万元的科研设备因信息混乱而长期闲置。另一方面，资产流转过程缺乏动态监控，借用、调拨、维修、报废等环节审批流程繁琐，责任划分模糊，不仅造成资产流失风险加剧，还导致资源配置失衡，部分部门设备闲置浪费，而另一部分部门却面临设备短缺的困境。此外，随着高校对精细化管理要求的提升，传统模式无法满足资产折旧核算、效益评估、预算编制等数据化决策需求，制约了高校资产管理的科学化进程。

同时，数字化转型已成为教育领域的必然趋势。《教育信息化2.0行动计划》明确提出，要推动高校管理流程数字化重构，实现"人、财、物"等核心资源的智能化管理。在此政策引导下，利用信息技术构建高效、精准、全流程的校园资产管理系统，成为解决当前管理困境的关键路径。

在企业层面，固定资产是企业生产经营的重要物质基础，其管理质量直接影响企业的运营效率与成本控制水平。随着企业规模扩大，传统资产管理方式的局限性日益凸显：资产台账数据与实物状态长期不一致，资产调拨、报废等操作缺乏规范流程，年度盘点消耗大量人力物力但准确率仍难以保证。构建一套信息化、流程化的企业资产管理系统，对于提升企业管理水平、保障资产安全、优化资源配置具有重要的现实意义。

综上，本研究以企业资产管理的实际需求为导向，设计并实现了一套基于Spring Boot与Vue 3技术栈的企业资产管理系统（EAMS），通过系统化、数字化手段构建资产全生命周期管理平台，以期为企业资产管理提供完整的技术解决方案。

## 1.2 国内外研究现状

国外高校及研究机构对资产管理系统的研究起步较早，且在数字化、智能化应用方面积累了丰富经验，其发展历程可分为三个阶段：

**基础信息化阶段（20世纪90年代-21世纪初）**：随着计算机技术的普及，国外率先突破传统人工管理模式，开始利用数据库技术构建资产信息管理系统。例如，美国斯坦福大学早期开发的AssetTrack系统，实现了资产信息的电子化存储与查询，解决了纸质台账易丢失、难更新的问题；英国剑桥大学则通过基于C/S架构的资产管理工具，初步实现了资产采购与入库流程的线上化，提升了管理效率。此阶段研究焦点集中于"数据标准化"，通过统一资产分类编码（如采用UNSPSC国际分类标准），为跨部门数据共享奠定基础。

**流程自动化阶段（2000年代-2010年代）**：随着企业资源计划（ERP）理念的渗透，国外高校开始将资产管理系统与财务、采购等系统集成，实现流程自动化。例如，美国加州大学伯克利分校的AssetWorks系统，通过工作流引擎实现资产借用、调拨、报废的线上审批，将流程处理时间从平均3天缩短至4小时；澳大利亚墨尔本大学则在系统中引入资产折旧算法（如直线法、双倍余额递减法），实现折旧自动计算与财务报表联动，满足审计合规要求。此阶段的技术特征是B/S架构普及与模块化设计，支持多终端访问与功能灵活扩展。

**智能协同阶段（2010年代至今）**：物联网（IoT）与人工智能（AI）技术的发展推动国外研究向智能化方向突破。例如，麻省理工学院（MIT）在实验室资产管理中应用RFID标签与智能传感器，实现资产位置实时追踪与状态监控（如设备运行温度、使用率），通过系统自动预警闲置资产，使设备利用率提升40%；德国慕尼黑工业大学则利用机器学习算法分析资产历史数据，预测设备故障风险与维护周期，降低了突发故障导致的教学科研中断概率。此外，国外商业化资产管理软件（如IBM Maximo、Oracle E-Business Suite）也被广泛应用于高校，其优势在于成熟的跨平台集成能力，但存在定制化成本高、难以适配高校特殊场景的问题。

国内研究起步相对较晚，但在政策推动与高校需求驱动下发展迅速，呈现"借鉴-创新-特色化"的演进路径：

**借鉴与本土化阶段（2000年代-2010年代）**：早期国内高校多参考国外ERP系统架构，结合国情开发简易资产管理工具。例如，清华大学2005年上线的"固定资产管理系统"，首次实现资产信息的集中化管理，解决了"账卡物不符"的核心痛点；北京大学则在系统中加入"教育部资产清查标准"模块，满足国家对高校资产监管的强制性要求。此阶段技术以Java+MySQL为主，功能集中于基础信息管理，尚未涉及流程自动化。

**功能深化与集成阶段（2010年代-2020年代初）**：随着"教育信息化十年发展规划（2011-2020年）"的实施，国内研究聚焦于"全生命周期管理"与"跨系统协同"。例如，浙江大学开发的资产全生命周期管理系统，覆盖从采购申请、招标、入库到报废处置的全流程，通过与校园一卡通系统对接，实现资产责任人与师生身份的绑定，明确管理责任；上海交通大学则将BIM（建筑信息模型）技术引入校园基建资产管理，实现教学楼、实验室等不动产的三维可视化管理，提升了大型资产的维护效率。此阶段的技术突破在于移动终端应用（如微信小程序盘点）与RFID批量识别，使资产盘点效率提升60%以上[1]。

**智慧化与特色化阶段（2020年代至今）**：国内研究在智能化技术应用与场景适配性上形成特色。例如，华中科技大学针对工科院校设备密集的特点，开发了"科研设备共享平台"，通过资产管理系统与设备预约系统联动，实现大型仪器的跨院系共享，使用率提升35%；深圳大学则利用大数据分析资产使用数据，为"双一流"建设中的设备采购预算提供决策支持，避免重复购置。此外，国内开源社区（如Gitee）涌现出一批轻量化资产管理系统（如基于Spring Boot框架的开源项目），降低了中小型企业的部署成本，但存在功能同质化、缺乏长期维护支持的问题。

综合国内外研究现状可以看出：（1）资产管理系统正由基础信息化向流程自动化、智能协同方向演进；（2）国内轻量化开源方案在中小型企业中有较大的应用空间，但当前开源方案普遍存在功能模块不完整、权限管理粗放、资产全生命周期管控缺失等不足；（3）基于主流技术栈（Spring Boot + Vue 3）构建的前后端分离轻量级企业资产管理系统，在兼顾功能完整性与部署便捷性方面具有较好的研究价值与应用前景。

## 1.3 论文主要内容

本论文聚焦于企业资产管理系统的设计与实现，旨在解决企业在资产管理过程中普遍面临的信息化程度低、流程不规范、账实不符等核心问题。系统以"资产全生命周期数字化管控"为核心设计理念，覆盖资产从采购申请、入库登记、使用分配、日常维护、定期盘点直至最终报废处置的全业务流程，构建了一套功能完整、操作便捷的数字化企业资产管理平台。

在技术实现上，系统采用前后端分离的现代化架构，后端基于Java 17与Spring Boot 3.1.5框架构建RESTful API服务，通过Spring Security框架与JWT技术实现无状态安全认证，利用MyBatis Plus简化持久层开发，Redis提供缓存加速支持；前端基于Vue 3.4.0与TypeScript 5.3.3构建，借助Element Plus组件库快速搭建企业级管理界面，ECharts实现业务数据的多维可视化展示。

系统核心实现了以下功能：

（1）**系统管理模块**：基于RBAC权限模型，实现用户、角色、部门、菜单权限的全面管控，支持菜单级与按钮级双层权限控制，保障系统访问的安全性与合规性；

（2）**资产管理模块**：支持多级树形分类管理，实现资产信息的完整台账录入，内置资产编号自动生成算法，提供资产入库、分配、调拨、归还、报废、送修等完整流转操作，通过操作日志全程追踪资产状态变更；

（3）**生命周期管理模块**：实现资产生命周期阶段的可视化追踪，提供全面盘点、抽样盘点、专项盘点三种模式的盘点管理功能，以及完整的报修申请→审批→维修→完成全流程管理；

（4）**采购管理模块**：提供多资产明细的采购申请、审批流程及批量入库功能，实现采购与资产台账的无缝衔接；

（5）**统计分析模块**：通过ECharts图表展示资产状态分布、部门资产分布、资产分类分布及时间趋势等多维度统计数据，支持管理层的决策分析。

## 1.4 论文组织结构

本论文共分为七章，各章节内容安排如下：

**第一章 绪论**：介绍研究背景与意义，阐述国内外资产管理系统的研究现状与发展趋势，明确论文的主要研究内容与组织结构。

**第二章 相关技术基础**：详细介绍系统开发所采用的主要技术，包括开发平台与工具、软硬件环境要求、后端技术栈（Spring Boot、MyBatis Plus、Spring Security、Redis、JWT等）、前端技术栈（Vue 3、TypeScript、Element Plus、Pinia、ECharts等）以及系统开发规范与约束。

**第三章 系统分析**：从技术可行性、操作可行性、经济可行性三个维度进行可行性分析；围绕用户角色定义、功能模块概述、核心功能详细需求开展功能性需求分析；并从性能、安全、可靠性、易用性、可维护性等方面明确非功能需求。

**第四章 系统设计**：进行系统总体结构设计，包括总体架构、技术架构、部署结构与安全架构设计；开展功能模块的详细设计；进行数据库设计，包含核心表结构设计与数据库关系设计；同时完成接口设计与页面设计。

**第五章 系统实现**：结合核心代码详细介绍后端实现与前端实现，重点阐述权限控制实现、资产自动编号生成、盘点明细分页查询、ECharts图表实现等关键技术的具体实现方案。

**第六章 系统测试**：制定系统测试策略，设计并执行功能测试用例，通过测试结果验证系统各模块的功能正确性与稳定性。

**第七章 总结与展望**：总结本论文的主要研究成果与创新点，指出系统的局限性与不足之处，展望系统后续的优化方向与发展前景。

## 1.5 本章小结

本章首先介绍了企业资产管理系统的研究背景，从高校资产管理数字化转型的迫切需求出发，深入分析了传统人工管理模式存在的账实不符、流转不透明、管理效率低等核心痛点，阐明了构建信息化资产管理系统的重要意义；随后梳理了国内外资产管理系统的研究现状与演进历程，总结了当前研究的主要趋势与不足；最后明确了本论文的研究内容与组织结构。本章为全文奠定了研究背景与方向基础，为后续系统的分析、设计与实现工作提供了问题导向与研究依据。

---

# 第2章 相关技术基础

## 2.1 开发平台及工具

### 2.1.1 开发平台

本系统在架构设计阶段充分考量了不同应用场景下的部署与开发需求，采用跨平台开发模式进行构建，能够兼容Windows、Linux、macOS等主流操作系统，保障开发团队可根据自身技术环境灵活选择开发载体，同时满足生产环境多样化的部署需求。

在操作系统层面，系统对开发环境与生产环境进行了差异化适配与规范：开发环境支持Windows 10/11、macOS 12及以上版本、Ubuntu 20.04及以上版本，覆盖了桌面端主流的操作系统版本，适配开发人员日常使用的终端设备；生产环境则优先推荐基于Linux内核的操作系统，具体包括CentOS 7及以上版本、Ubuntu 20.04及以上版本，该选择兼顾了生产环境对稳定性、安全性和资源利用率的核心要求，符合企业级应用部署的行业通用标准。

Java开发环境作为系统开发的核心基础，统一采用JDK 17（Long-Term Support，长期支持版本）作为标准开发套件。JDK 17作为LTS版本，既能够提供长期的技术支持与维护保障，也支持其包含的各类核心语言特性，如记录类（Record Classes）、模式匹配（Pattern Matching）、密封类（Sealed Classes）等，这些特性可有效简化代码结构、提升开发效率，同时保证代码的健壮性与可维护性，为系统的开发与迭代奠定了坚实的技术基础。

### 2.1.2 开发工具

本系统在开发工具链的选型上，充分结合不同开发环节的技术特性与行业最佳实践，为后端、前端、数据库管理等核心开发场景制定了明确的工具版本规范，保障开发流程的标准化与高效性。

在开发集成环境（IDE）层面，针对后端开发场景，指定IntelliJ IDEA 2023及以上版本或Eclipse 2023及以上版本作为核心开发工具，两款工具均具备完善的Java开发支持能力，适配JDK 17的语法特性与项目构建需求；前端开发则统一采用Visual Studio Code 1.80及以上版本，该工具凭借轻量化、高扩展性的特性，结合丰富的前端插件生态，可高效支撑前端代码的编辑、编译与调试工作。

数据库管理环节，系统兼容Navicat Premium、MySQL Workbench、DBeaver三款主流工具，既覆盖了商业化工具的便捷性，也包含开源工具的灵活性。版本控制层面，采用Git 2.30及以上版本作为代码版本管理工具，依托Git的分布式版本控制特性，保障多人协作开发时的代码一致性与追溯性。

API测试环节，支持Postman与Swagger UI两类工具：Postman可满足接口的手动测试、自动化测试与压力测试需求；Swagger UI则通过接口文档的自动生成与可视化展示，实现接口定义与测试的一体化。构建工具方面，后端采用Maven 3.8及以上版本进行项目构建，前端则使用npm 9及以上版本完成前端依赖安装、项目编译与打包。

## 2.2 软硬件环境

### 2.2.1 服务器硬件环境

本系统在部署与运行环节，结合不同应用场景的资源需求，制定了分级的硬件配置标准：

| 配置项 | 最低配置 | 推荐配置 |
|--------|----------|----------|
| CPU | 双核，主频2.0GHz以上 | 四核，主频2.5GHz以上 |
| 内存 | 4GB RAM | 8GB RAM以上 |
| 硬盘 | 50GB以上 | 100GB SSD以上 |
| 网络带宽 | 100Mbps | 1Gbps以上 |
| 操作系统 | CentOS 7+/Ubuntu 20.04+ | CentOS 8+/Ubuntu 22.04+ |

最低配置标准适配小型部署场景、开发测试环境或低并发业务场景；推荐配置标准能够充分释放系统性能，适配企业级的业务运行需求。

### 2.2.2 客户端硬件环境

客户端硬件要求相对宽松，CPU双核1.5GHz以上、内存4GB以上、显示器分辨率1920×1080及以上，即可保证系统界面的完整呈现。在软件环境层面，系统支持Chrome 90+、Firefox 88+、Edge 90+、Safari 14+等主流浏览器，覆盖Windows、macOS等不同操作系统环境，保障跨终端访问的兼容性。

### 2.2.3 运行端口配置

| 服务 | 端口 | 说明 |
|------|------|------|
| 后端服务 | 9998 | Spring Boot应用端口 |
| 前端开发服务 | 3000 | Vite开发服务器端口 |
| MySQL数据库 | 3306 | 数据库服务端口 |
| Redis缓存 | 6379 | 缓存服务端口 |

## 2.3 后端技术栈

### 2.3.1 核心框架

本系统后端核心开发框架采用Spring Boot 3.1.5与Spring Framework 6.0组合体系，两款框架均为Spring生态的核心组件，适配Java 17的技术规范，为系统提供了轻量化、高性能且易扩展的开发与运行基础。

Spring Boot 3.1.5是经过生产环境验证的稳定版本，全面兼容JDK 17运行环境，其核心特性为系统开发与部署提供了关键支撑：一是自动配置机制，可根据项目依赖自动完成框架层面的配置，大幅减少手动配置工作量；二是起步依赖（Starter）设计，将常用功能模块的依赖进行封装，开发者可通过简单引入依赖实现功能集成；三是内嵌Tomcat 10服务器，无需额外部署应用服务器即可运行项目，显著简化了系统的部署流程。

Spring Framework 6.0作为Spring生态的基础核心框架，其核心能力覆盖系统开发的关键环节：IoC（控制反转）容器统一管理业务Bean的生命周期，实现依赖注入；AOP（面向切面编程）特性支持将日志记录、权限控制等横切关注点与核心业务代码解耦；Spring MVC模块快速构建符合RESTful风格的API接口；Spring Security组件提供完整的认证授权解决方案。

### 2.3.2 持久层框架

本系统持久层采用MyBatis Plus 3.5.7作为核心操作框架，该框架是基于MyBatis的轻量化增强工具，遵循"只做增强、不做改变"的设计原则，在兼容MyBatis原有功能的基础上，大幅简化了数据库操作的开发成本。其核心特性包括：内置通用Mapper组件，无需编写XML映射文件即可完成基础CRUD操作；支持Lambda表达式查询，通过类型安全的语法避免字符串拼接错误；内置分页插件，快速实现分页查询；集成自动填充（create_time、update_time）、逻辑删除（deleted字段）等实用功能。

### 2.3.3 数据库

系统核心数据存储采用MySQL 8.0开源关系型数据库。MySQL 8.0原生支持事务处理、外键约束等核心特性，能够保障数据的一致性与完整性；默认采用InnoDB存储引擎，全面支持ACID事务特性；字符集统一配置为utf8mb4，可完整支持Unicode字符集，避免因字符编码问题导致的数据存储异常；时区配置为Asia/Shanghai，保证时间数据的准确性。

### 2.3.4 缓存与中间件

系统缓存层选用Redis 6.0及以上版本作为高性能键值对存储中间件，其基于内存的存储特性赋予了极高的数据读写效率，可有效缓解数据库访问压力。Redis在本系统中的主要应用场景包括：用户权限信息缓存，减少权限校验时的数据库查询次数；Token黑名单存储，快速校验失效Token；会话管理，实现分布式场景下的用户会话共享；热点数据缓存，对高频访问的业务数据进行缓存，提升系统响应速度。系统采用Lettuce作为Redis客户端，配合Apache Commons Pool2进行连接池管理。

### 2.3.5 安全框架

系统安全管控体系以Spring Security 6.1为核心框架，提供了完整的认证（Authentication）与授权（Authorization）解决方案。其核心能力包括：支持多种认证方式，可与JWT无缝集成，实现无状态认证模式；支持基于@PreAuthorize注解的方法级别权限控制，精细化管控接口与方法的访问权限。

在JWT实现层面，系统采用JJWT 0.12.5作为Java端JWT处理库。Token配置遵循标准化规范：有效期设定为7天（604800秒），兼顾安全性与用户使用体验；采用HS256对称加密算法进行Token签名，保障Token在传输与存储过程中的完整性与防篡改性。

密码安全方面，系统采用BCrypt算法对用户密码进行哈希加密存储。BCrypt算法内置了盐值机制，即使相同的密码也会生成不同的哈希值，有效防止彩虹表攻击，是目前密码安全存储的最佳实践之一。

### 2.3.6 工具类库

本系统开发过程中集成了多款成熟的Java工具库：

**Lombok**：通过注解机制自动生成Java类的样板代码，常用注解包括@Data、@Getter/@Setter、@Builder、@Slf4j等，大幅精简实体类代码量。

**Hutool 5.8.25**：一站式Java工具类库，提供DateUtil（日期处理）、StrUtil（字符串操作）、SecureUtil（加密解密）、HttpUtil（HTTP客户端）等丰富工具方法。

**MapStruct 1.5.5**：Java Bean映射框架，采用编译期生成映射代码的方式，主要用于Entity、DTO、VO之间的属性转换，避免手动编写大量重复的对象转换代码。

**Apache POI 5.2.5**：Office文档处理组件，提供Microsoft Office格式文档的读写能力，核心应用于资产数据的批量Excel导入和报表数据的Excel导出场景。

### 2.3.7 API文档

系统采用SpringDoc OpenAPI 2.2.0（兼容Swagger 3）作为API文档管理工具，实现RESTful API文档的自动化生成与可视化管理。该工具可基于代码注解自动解析接口信息，生成标准化的API文档；提供交互式的API测试界面，开发者可直接在界面中发起接口请求；支持通过@Operation、@Parameter等注解增强文档信息。系统API文档的访问地址为`http://localhost:9998/api/swagger-ui.html`。

### 2.3.8 其他组件

**WebSocket**：实现服务端向客户端的实时消息推送，主要应用于盘点进度实时通知、系统重要消息推送等场景，让用户无需手动刷新页面即可获取最新业务状态。

## 2.4 前端技术栈

### 2.4.1 核心框架

本系统前端开发基于Vue 3.4.0与TypeScript 5.3.3构建核心技术体系。Vue 3.4.0采用Composition API开发模式，相较于传统Options API，可更灵活地组织与复用业务逻辑代码；其响应式系统基于ES6的Proxy特性重构，支持对数组、对象属性的全量监听；整体性能相较于Vue 2有显著优化，降低了运行时的内存占用与渲染耗时。

TypeScript 5.3.3通过添加静态类型检查机制，弥补了JavaScript弱类型的缺陷：在开发阶段即可发现类型相关错误；为IDE提供精准的代码提示与重构支持；支持接口、泛型、装饰器等高级特性，能够更好地抽象业务逻辑、规范数据结构。

### 2.4.2 构建工具

系统前端构建环节选用Vite 5.0.8作为核心工具，相较于传统Webpack具备显著的性能优势：基于原生ES Module实现快速冷启动，无需等待打包完成即可启动开发服务器；热模块替换（HMR）机制可实现代码修改后的即时更新，大幅缩短开发调试的反馈周期；生产环境下基于Rollup进行打包，生成体积更小、性能更优的构建产物。

### 2.4.3 UI组件库

系统界面开发集成Element Plus 2.5.0及其官方图标库@element-plus/icons-vue 2.3.1。Element Plus 2.5.0是适配Vue 3的企业级组件库，覆盖表单、表格、树形控件、分页、对话框、消息提示、菜单等各类UI组件；支持按需引入机制，有效减小最终构建产物的体积；具备完善的TypeScript类型定义，与TypeScript的配合良好。

### 2.4.4 状态管理

系统前端状态管理采用Pinia 2.1.7，该库是Vue 3官方推荐的状态管理方案。相比Vuex，Pinia具备更贴合现代前端开发的特性：对TypeScript提供原生级别的支持；API设计更为简洁，无需嵌套的模块与命名空间；支持模块化Store设计，可按业务域拆分状态，实现状态的隔离与复用。

### 2.4.5 路由管理

前端路由控制基于Vue Router 4.2.5实现，支持嵌套路由、动态路由、路由守卫等特性。系统利用动态路由功能根据用户权限动态生成路由规则，实现页面访问权限的精细化控制；路由懒加载机制将不同路由对应的组件拆分为独立代码块，有效优化首屏加载性能。

### 2.4.6 HTTP客户端

系统前后端数据交互基于Axios 1.6.2实现。系统通过请求/响应拦截器统一处理Token添加、响应数据格式化、异常捕获等逻辑；能够自动转换JSON格式的请求与响应数据；提供请求取消机制，避免无效的网络请求占用资源。

### 2.4.7 数据可视化

系统数据可视化需求基于ECharts 6.0.0实现，该库是百度开源的高性能可视化图表库。系统在仪表盘模块中使用ECharts展示资产状态分布饼图、部门资产分布柱状图、资产数量时间趋势折线图以及资产分类分布图，将抽象的业务数据转化为直观的图表形式，辅助管理层快速掌握核心业务指标。

## 2.5 开发规范及约束

### 2.5.1 后端框架分层规范

本系统后端架构采用经典的三层架构模式，各层级核心职责明确：

- **Controller层**：接收HTTP请求，完成请求参数的合法性校验，处理请求路由分发，将业务处理结果封装为统一格式返回给前端；
- **Service层**：承接Controller层的请求，实现各类业务规则、流程控制与事务管理，是系统核心业务能力的载体；
- **Mapper层**：专注于数据持久化操作，负责与数据库的交互，执行SQL语句完成数据的增删改查。

### 2.5.2 数据传输对象规范

系统制定了明确的数据传输对象设计规范，将数据载体划分为三类核心对象：

- **Entity（实体类）**：与数据库表结构一一对应，仅用于数据持久化层；
- **DTO（Data Transfer Object）**：专门用于接收前端传入的请求参数；
- **VO（View Object）**：作为返回给前端的专用数据载体，按需筛选、组装数据字段，隐藏敏感信息。

三者遵循"分离原则"，禁止将Entity直接暴露给前端，有效降低前端与数据库层的耦合度。

### 2.5.3 统一响应格式规范

系统所有RESTful API接口的返回结果均通过统一的Result对象进行包装：

```json
{
  "code": 200,
  "message": "操作成功",
  "data": {}
}
```

其中，code字段为状态码（200成功、400参数错误、401未认证、403无权限、500服务器异常）；message字段为信息描述；data字段为业务数据载体。

### 2.5.4 命名规范

**后端命名规范：**
- 类名：大驼峰命名法（PascalCase），如UserService、AssetController
- 方法名/变量名：小驼峰命名法（camelCase），如getUserById、assetName
- 常量名：全大写字母，下划线分隔，如MAX_SIZE、TOKEN_EXPIRE_TIME
- 包名：全小写字母，如com.eams.system、com.eams.asset.mapper

**前端命名规范：**
- 组件名：大驼峰命名法，如UserManagement.vue、AssetTable.vue
- 方法名/变量名：小驼峰命名法，如fetchUserList、handleFormSubmit

**数据库命名规范：**
- 表名：全小写，下划线分隔，如sys_user、asset_info
- 字段名：全小写，下划线分隔，如create_time、user_name
- 索引名：idx_表名_字段名格式，如idx_user_username

## 2.6 本章小结

本章阐述了本系统开发所依托的相关技术基础与规范体系，全面梳理了系统开发部署环境、核心技术栈选型、架构设计原则及编码规范等关键内容。在开发部署环境方面，本章明确系统采用跨平台开发模式，开发环境支持Windows 10/11、macOS 12+、Ubuntu 20.04+等主流操作系统，生产环境优先推荐Linux系列操作系统；制定了分级硬件配置标准，保障系统在不同场景下的稳定运行。

核心技术栈选型上，后端以Spring Boot 3.1.5与Spring Framework 6.0为核心框架，搭配MyBatis Plus 3.5.7持久层框架、MySQL 8.0数据库及Redis 6.0+缓存中间件，整合Spring Security 6.1与JWT构建安全体系；前端以Vue 3.4.0与TypeScript 5.3.3为核心，结合Vite 5.0.8构建工具、Element Plus UI组件库及各类辅助框架。此外，本章还阐述了后端三层架构设计、DTO/VO分离原则、统一响应格式规范及全维度命名规范，为系统后续开发工作的有序开展提供了完整的技术指导。

---
# 第3章 系统分析

## 3.1 可行性分析

### 3.1.1 技术可行性

本系统在技术选型上遵循成熟、高效、可靠的核心原则，选用Spring Boot、Vue 3等业界主流核心技术，各核心技术优势如下所述。

系统所采用技术的成熟度处于行业较高水平，为系统的稳定运行提供了坚实的技术支撑。Spring Boot作为后端开发的核心框架，Vue 3作为前端开发的主流技术，均已在国内外各类软件项目中广泛应用，经过大量实际场景的检验，技术稳定性与适用性得到充分验证。两类核心技术均拥有官方完善的技术文档，覆盖从基础入门到高级应用的全流程指导；活跃的开源社区持续为技术迭代更新提供支持；围绕核心技术形成的成熟技术生态，配套有丰富的第三方库与工具插件，可满足系统开发过程中的各类个性化需求。

高效的开发模式是本系统快速落地的重要保障。后端开发中，Spring Boot框架的自动配置机制有效减少了重复开发工作量；MyBatis Plus提供了通用CRUD接口与灵活的条件构造器，无需为基础的数据操作编写重复的SQL语句。前端开发方面，Vue 3框架结合Element Plus组件库提供了丰富的预置UI组件，可快速构建美观易用的前端界面；系统采用前后端分离架构，前后端开发工作可并行开展，有效提升项目整体交付质量。

系统具备较强的扩展性，采用模块化开发模式，将不同业务功能拆分为独立的模块，各模块之间通过标准化接口通信，当需要新增业务功能时可直接对对应模块进行修改与扩展。系统遵循RESTful API设计规范，便于与外部系统集成对接。

### 3.1.2 操作可行性

系统注重用户使用体验，具备友好的用户界面与较低的学习成本。前端采用Element Plus组件库，提供美观、现代且兼容的UI组件，结合合理的界面布局，打造出简洁直观、交互流畅的用户界面。系统操作流程遵循主流用户使用习惯，简化了复杂业务的操作步骤；表单交互方面内置即时验证功能，用户输入时可实时获取验证反馈。

系统界面布局清晰规整，各类功能按业务场景合理分类，用户可快速定位所需功能。对于删除、修改等关键操作，系统设置了确认提示机制，避免用户因误操作造成数据丢失；系统的错误提示信息简洁明确，精准指出问题原因，帮助用户快速排查问题。

系统部署与维护流程简单便捷。后端基于Spring Boot框架开发，可打包为单一jar文件，简化了部署流程；前端代码打包为静态资源，可灵活部署到各类Web服务器。运维人员无需具备复杂的技术能力即可完成系统的日常部署、监控与维护工作。

### 3.1.3 经济可行性

本系统在开发过程中严格控制投入成本。在技术栈成本方面，系统全部采用开源技术构建，核心框架、组件及工具均免费使用，零许可证成本是相比商业软件的显著优势。在开发成本方面，基于Spring Boot的快速开发特性与MyBatis Plus的代码简化能力，可有效缩短开发周期，降低人力成本；前后端分离架构允许前后端开发并行推进，进一步提升开发效率。在运维成本方面，系统支持在普通Linux服务器上部署运行，无需高端硬件支撑，大幅降低了硬件投入与运维成本。

系统投入使用后，将产生多维度的预期收益：在管理效率提升方面，系统实现资产流转全流程数字化管理，替代传统人工操作，减少人工录入、审核、统计等工作量，预计可将资产管理人员的日常操作效率提升60%以上；在资产盘点方面，系统支持全面盘点、抽样盘点、专项盘点三种模式，通过系统化的盘点流程，可将传统人工盘点所需时间缩减50%以上；在资产损失控制方面，完整的资产流转追踪与权限控制体系，能够有效减少资产流失现象；在决策支持方面，丰富的统计分析图表为管理层提供了直观的数据支撑，助力科学决策。

综合以上分析，系统的开发投入合理可控，且具有明显的经济效益与管理效益，经济可行性较强。

## 3.2 功能性需求分析

### 3.2.1 用户角色定义

根据企业资产管理的实际业务场景，系统设计了以下用户角色：

**系统管理员（Admin）**：系统最高权限角色，拥有所有操作权限，核心职责涵盖用户与权限管理、系统配置及日志审计。可全面管理系统内所有用户信息、角色分配及部门架构，确保用户权限与岗位职责相匹配；同时负责系统配置维护、数据字典管理及日志监控。

**资产管理员（Asset Manager）**：负责资产台账管理，权限覆盖资产分类管理、资产信息的增删改查、资产流转操作（入库、分配、调拨、归还、报废、送修等）及资产流转记录的查询与审计。

**采购员（Purchaser）**：负责采购业务管理，具备采购申请提交、采购明细维护及采购记录查询的操作权限；当采购审批通过后，可执行采购入库操作，将采购物品转入资产台账。

**盘点员（Inventory Checker）**：负责资产盘点工作的执行与记录，具备盘点计划查看与盘点明细录入权限，在盘点过程中逐一确认资产实物状态并记录盘点结果，为管理层提供真实的资产实物数据。

**维修人员（Repair Person）**：负责已批准报修工单的维修工作，具备维修工单接收、维修进度更新、维修结果录入及维修费用记录权限。

**审批人员（Approver）**：负责采购申请与报修申请的审批，具备申请查看权限，可执行审批操作（同意/拒绝）并填写审批意见。

**普通用户（Normal User）**：仅有基础的信息查看权限，可查看与本人相关的资产分配信息、报修工单状态等只读信息。

### 3.2.2 功能模块概述

系统功能模块划分如下：

```
企业资产管理系统（EAMS）
├── 系统管理模块
│   ├── 用户管理
│   ├── 角色管理
│   ├── 部门管理
│   └── 菜单权限管理
├── 资产管理模块
│   ├── 资产分类管理
│   ├── 资产信息管理
│   └── 资产流转记录
├── 生命周期管理模块
│   ├── 生命周期追踪
│   ├── 盘点管理
│   └── 报修管理
├── 采购管理模块
│   ├── 采购申请与审批
│   └── 采购入库
└── 统计分析模块
    └── 仪表盘（Dashboard）
```

**系统管理模块**：作为系统运行的基础支撑模块，核心聚焦于用户、角色、部门及权限的规范化管控。用户管理支持新增、修改、删除、启用/禁用用户，以及重置密码和绑定部门；角色管理支持角色的创建与维护，并支持为角色分配菜单权限（菜单级与按钮级双层权限）；部门管理支持多层级树形部门结构的维护；菜单权限管理支持系统菜单与按钮权限的配置。

**资产管理模块**：提供完整的资产台账管理能力。资产分类管理支持多级树形分类结构；资产信息管理覆盖资产全要素信息的录入与维护（包括资产编号、名称、分类、规格型号、生产厂商、采购金额、采购日期、使用部门、责任人等）；资产流转记录全程追踪资产的每一次状态变更操作。

**生命周期管理模块**：管理资产从入库到报废的全生命周期。生命周期追踪提供资产各阶段状态的时间轴展示；盘点管理提供三种盘点模式（全面盘点、抽样盘点、专项盘点）的完整管理；报修管理提供从报修申请到维修完成的全流程管理。

**采购管理模块**：管理资产采购的全流程。采购申请支持多资产明细的采购单创建；审批流程支持审批人对采购申请进行审批操作；采购入库支持将审批通过的采购物品批量转入资产台账。

**统计分析模块**：通过ECharts图表直观展示核心业务指标，包括资产总数、部门资产分布、资产状态分布、资产分类分布及资产数量时间趋势等统计数据。

### 3.2.3 核心功能详细需求

#### 3.2.3.1 用户与权限管理需求

系统采用RBAC（基于角色的访问控制）权限模型，用户通过关联角色获得对应的操作权限。权限粒度分为两个层级：菜单权限（控制页面访问）和按钮权限（控制页面内操作权限，如新增、编辑、删除等）。

用户管理核心需求：
- 支持用户信息的增删改查，必填字段包括用户名、姓名、密码、手机号；
- 支持启用/禁用用户状态，禁用用户无法登录系统；
- 支持重置密码操作，由管理员将密码重置为默认值；
- 支持用户与部门的绑定，实现数据权限的部门范围控制；
- 支持用户与角色的绑定，用户可绑定多个角色；
- 用户密码采用BCrypt算法加密存储，系统不存储明文密码。

角色管理核心需求：
- 支持角色信息的增删改查，必填字段包括角色名称、角色标识（唯一）；
- 支持为角色分配菜单权限，采用树形结构展示菜单层级，支持全选/反选操作；
- 支持菜单级与按钮级双层权限控制，精细管控不同角色的操作范围。

#### 3.2.3.2 资产管理需求

资产信息管理核心需求：
- 资产编号由系统自动生成，格式为 ASSET-YYYYMMDD-序列号（如ASSET-20260115-001），确保全局唯一性；
- 必填字段：资产名称、资产分类、采购金额、采购日期、使用部门；
- 可选字段：规格型号、生产厂商、责任人、备注；
- 资产状态包含：0-采购中、1-闲置、2-使用中、3-维修中、4-报废、6-取消采购；
- 支持按资产名称、资产编号、分类、状态、部门等条件筛选查询，支持分页显示；
- 支持资产数据的Excel导入批量录入和Excel导出功能。

资产流转操作需求：

| 操作 | 说明 | 前置状态 | 后置状态 |
|------|------|----------|----------|
| 入库 | 新采购资产入库登记 | 采购中 | 闲置 |
| 分配 | 将资产分配至指定部门/责任人 | 闲置 | 使用中 |
| 调拨 | 在部门/责任人之间转移资产 | 使用中 | 使用中 |
| 归还 | 归还正在使用的资产 | 使用中 | 闲置 |
| 报废 | 对不可用资产进行报废处理 | 闲置/使用中 | 报废 |
| 送修 | 将故障资产送往维修 | 使用中/闲置 | 维修中 |
| 维修完成 | 维修完成后恢复资产 | 维修中 | 使用中/闲置 |

#### 3.2.3.3 盘点管理需求

盘点管理支持三种盘点模式：

- **全面盘点**：对系统中所有资产进行全量盘点，适用于年度资产清查；
- **抽样盘点**：从资产中随机抽取指定数量进行盘点，适用于日常抽查；
- **专项盘点**：对指定资产分类进行盘点，适用于专类资产核查。

盘点流程：创建盘点计划（设置盘点名称、类型、计划时间）→ 开始盘点（系统自动生成盘点明细）→ 执行盘点（逐一确认资产实物状态，记录正常/异常）→ 完成盘点（生成盘点结果统计报告）。

盘点明细需记录每项资产的盘点状态（正常/盘盈/盘亏/损坏），系统统计应盘数量、实盘数量、正常数量、异常数量。

#### 3.2.3.4 报修管理需求

报修流程：提交报修申请 → 审批 → 维修处理 → 完成，各阶段状态分别为：待审批/已审批/维修中/已完成/已拒绝。

报修申请必填信息：资产（从台账选取）、故障描述、报修类型（日常维修/故障维修/预防性维修）、优先级（紧急/普通/低）。审批通过后，维修人员需记录维修开始时间、维修人、维修费用、维修结果；维修完成后，资产状态自动恢复至维修前状态。

#### 3.2.3.5 采购管理需求

采购流程：提交采购申请（填写供应商、采购日期、采购明细） → 采购审批 → 采购入库。

采购明细支持多行录入，每行包含：资产名称、资产分类、规格型号、单价、数量，系统自动计算总金额。审批通过后，系统支持批量入库操作，自动为每项采购明细生成资产记录并赋予初始状态"采购中"。

## 3.3 非功能需求

### 3.3.1 性能需求

- **响应时间**：普通查询请求（单表查询、列表查询）响应时间不超过500ms；复杂查询（多表关联、统计分析）响应时间不超过2秒；Excel导出操作（1000条以内）完成时间不超过10秒；
- **并发支持**：系统应支持不少于100个并发用户同时访问，核心业务接口QPS（每秒查询数）不低于50；
- **数据规模**：单表数据量支持100万条以上，分页查询性能稳定；
- **可用性**：系统年可用率不低于99.9%，计划外停机时间不超过8.76小时/年。

### 3.3.2 安全需求

- 所有API接口（除登录接口外）必须携带有效的JWT Token方可访问，Token有效期为7天；
- 严格执行RBAC权限控制，未授权操作返回403禁止访问；
- 用户密码采用BCrypt算法加密存储，系统日志不记录明文密码；
- 系统应防范SQL注入、XSS跨站脚本、CSRF跨站请求伪造等常见攻击；
- 重要操作（删除、修改、审批等）全程记录操作日志，包含操作人、操作时间、操作内容。

### 3.3.3 可靠性需求

- 系统数据库应进行定期备份，支持数据的快速恢复；
- 采用逻辑删除机制，防止数据误删后无法恢复；
- 所有关键业务操作应在事务保护下执行，保证数据一致性；
- 系统应提供全局异常处理机制，确保任何异常都能被捕获并返回友好的错误信息。

### 3.3.4 易用性需求

- 界面设计简洁直观，遵循主流企业管理系统的设计规范；
- 表单提供实时输入验证，操作结果提供即时反馈；
- 支持Chrome、Firefox、Edge、Safari等主流浏览器，最低支持版本分别为90、88、90、14；
- 页面在1920×1080分辨率下应完整显示所有功能元素。

### 3.3.5 可维护性需求

- 代码遵循统一的命名规范与注释规范，核心方法、类必须提供中文注释；
- 采用分层架构，各层职责清晰，便于单独维护与扩展；
- 提供完整的API文档（Swagger），方便前后端协作与接口维护；
- 日志记录完善，系统运行异常可通过日志快速定位问题。

## 3.4 本章小结

本章从可行性分析和需求分析两个维度，对企业资产管理系统进行了全面深入的分析。在可行性分析方面，从技术可行性、操作可行性、经济可行性三个角度，论证了系统建设的可行性：技术栈成熟稳定，开发效率高，系统扩展性强；界面操作友好，部署维护简便；技术成本低廉，经济效益显著。

在需求分析方面，本章定义了系统的用户角色体系（系统管理员、资产管理员、采购员、盘点员、维修人员、审批人员、普通用户），详细阐述了五大功能模块（系统管理、资产管理、生命周期管理、采购管理、统计分析）的具体功能需求，包含完整的操作流程、状态流转和业务规则描述；同时明确了系统在性能、安全、可靠性、易用性、可维护性方面的非功能需求。本章的分析结果为后续系统设计与实现工作提供了清晰、完整的需求基准。

---

# 第4章 系统设计

## 4.1 系统结构设计

### 4.1.1 总体架构设计

本系统采用前后端分离的总体架构，将系统划分为前端层（Web Browser）、接口层（API Gateway）、业务层（Spring Boot Backend）和数据层（Database & Cache）四个核心层次，各层通过标准化的接口协议通信，实现层间的松耦合。系统总体架构如下图所示：

```
┌─────────────────────────────────────────────────────────┐
│                    用户浏览器（Client）                    │
│              Vue 3 + TypeScript + Element Plus            │
└────────────────────────┬────────────────────────────────┘
                         │ HTTP/HTTPS (RESTful API + JSON)
┌────────────────────────▼────────────────────────────────┐
│                  Spring Boot 后端服务                      │
│   ┌────────────┐  ┌────────────┐  ┌────────────────┐   │
│   │ Controller │→ │  Service   │→ │  Mapper/DAO    │   │
│   │ (路由分发) │  │ (业务逻辑) │  │ (数据访问层)   │   │
│   └────────────┘  └────────────┘  └────────────────┘   │
│   ┌────────────────────────────────────────────────┐    │
│   │  Spring Security + JWT (认证授权)               │    │
│   └────────────────────────────────────────────────┘    │
│   ┌────────────────────────────────────────────────┐    │
│   │  AOP 切面 (日志记录 / 权限控制)                │    │
│   └────────────────────────────────────────────────┘    │
└────────────┬────────────────────────┬───────────────────┘
             │                        │
┌────────────▼──────┐    ┌────────────▼──────────────────┐
│  MySQL 8.0        │    │  Redis 6.0+                    │
│  (持久化存储)      │    │  (缓存 / Session)              │
└───────────────────┘    └────────────────────────────────┘
```

**前端层**：基于Vue 3.4.0 + TypeScript + Element Plus构建，通过Axios与后端进行HTTP数据交互，Pinia管理前端状态，Vue Router实现页面路由，ECharts实现数据可视化。前端通过请求拦截器统一添加JWT Token，通过响应拦截器统一处理错误。

**接口层**：后端Controller层接收HTTP请求，完成参数校验（Bean Validation），将请求分发至对应的Service处理，所有请求均需经过Spring Security过滤器链的认证与鉴权。

**业务层**：Service层实现核心业务逻辑，AOP切面负责操作日志的非侵入式记录，全局异常处理器统一处理各类异常。

**数据层**：MyBatis Plus负责MySQL的ORM操作，Redis负责缓存加速和会话管理。

### 4.1.2 技术架构

系统后端采用Spring生态构建技术架构：

```
┌─────────────────────────────────────────────┐
│             Spring Boot 应用层               │
│                                             │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐   │
│  │ asset    │ │lifecycle │ │purchase  │   │
│  │ module   │ │ module   │ │ module   │   │
│  └──────────┘ └──────────┘ └──────────┘   │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐   │
│  │ system   │ │dashboard │ │ security │   │
│  │ module   │ │ module   │ │ module   │   │
│  └──────────┘ └──────────┘ └──────────┘   │
│                                             │
│  ┌──────────────────────────────────────┐  │
│  │  common / config / aop / exception   │  │
│  └──────────────────────────────────────┘  │
└─────────────────────────────────────────────┘
```

### 4.1.3 部署结构设计

系统采用单机部署模式，适合中小型企业的资产管理场景：

```
┌─────────────────────────────────────────────────────────┐
│                    应用服务器（Linux）                     │
│                                                         │
│  ┌──────────────────┐    ┌──────────────────────────┐  │
│  │  Nginx           │    │  Spring Boot Application │  │
│  │  (端口: 80/443)  │───▶│  (端口: 9998)            │  │
│  │  静态资源托管     │    │  (eams.jar)              │  │
│  │  反向代理        │    └──────────────────────────┘  │
│  └──────────────────┘                                   │
│                                                         │
│  ┌──────────────────┐    ┌──────────────────────────┐  │
│  │  MySQL 8.0       │    │  Redis 6.0+              │  │
│  │  (端口: 3306)    │    │  (端口: 6379)             │  │
│  └──────────────────┘    └──────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

### 4.1.4 安全架构设计

系统安全架构分为四个层次：

```
┌──────────────────────────────────────────────────────────┐
│  网络安全层: HTTPS / Nginx 访问控制 / 防火墙              │
├──────────────────────────────────────────────────────────┤
│  认证层: JWT Token 无状态认证 / BCrypt 密码加密            │
│  (Spring Security 过滤器链 → JWT 过滤器 → UserDetails)   │
├──────────────────────────────────────────────────────────┤
│  授权层: RBAC 权限控制                                    │
│  (用户 → 角色 → 权限 / 菜单级 + 按钮级双层鉴权)           │
├──────────────────────────────────────────────────────────┤
│  数据安全层: 逻辑删除 / 操作日志 / 输入校验 / SQL防注入   │
└──────────────────────────────────────────────────────────┘
```

**JWT认证流程：**

```
客户端                          服务端
  │                               │
  │──POST /api/auth/login──────▶  │ 验证用户名/密码
  │                               │ 生成 JWT Token（有效期7天）
  │◀──返回 Token──────────────    │
  │                               │
  │──GET /api/asset/list          │
  │  Header: Authorization: Bearer <token>
  │                               │ JWT过滤器解析Token
  │                               │ 校验Token有效性
  │                               │ 加载用户权限信息
  │                               │ 执行业务逻辑
  │◀──返回数据────────────────    │
```

## 4.2 功能模块设计

### 4.2.1 模块划分

系统按业务领域划分为五个一级功能模块，各模块职责清晰、边界明确：

| 模块 | 包路径 | 核心职责 |
|------|--------|----------|
| 系统管理 | com.eams.system | 用户、角色、部门、菜单权限管理 |
| 资产管理 | com.eams.asset | 资产分类、资产台账、流转记录 |
| 生命周期管理 | com.eams.lifecycle | 盘点管理、报修管理、生命周期追踪 |
| 采购管理 | com.eams.purchase | 采购单、采购明细、采购入库 |
| 统计分析 | com.eams.dashboard | 仪表盘统计数据 |
| 公共组件 | com.eams.common | 统一返回、枚举、工具类 |
| 配置组件 | com.eams.config | Spring Security、Redis、MyBatis配置 |
| 安全组件 | com.eams.security | JWT工具类、Security过滤器 |
| AOP组件 | com.eams.aop | 操作日志切面 |
| 异常处理 | com.eams.exception | 全局异常处理器 |

### 4.2.2 资产管理模块详细设计

资产管理模块是系统的核心模块，包含资产分类、资产信息、流转记录三个子模块。

**资产状态流转设计：**

```
         采购中(0)
            │ 入库
            ▼
         闲置(1) ◀──── 归还
            │  ────────────────────────────────┐
         分配│                                   │
            ▼                                   │
         使用中(2) ──── 调拨 ──── 使用中(2)      │
            │  │                                │
       报废  │  │ 送修                            │ 报废
            ▼  ▼                               ▼
         报废(4) 维修中(3) ── 维修完成 ──▶ 使用中/闲置
```

**资产编号自动生成设计：**

系统设计了全局唯一的资产编号生成策略，基于数据库序列表（asset_number_sequence）实现：
- 编号格式：ASSET-{YYYYMMDD}-{3位序号}，例如ASSET-20260115-001
- 每日序号从001开始重置
- 通过数据库事务与行锁保证高并发下编号的唯一性

### 4.2.3 盘点管理模块详细设计

**盘点流程状态机：**

```
创建盘点计划 → [计划中(1)] → 开始盘点 → [进行中(2)] → 完成盘点 → [已完成(3)]
                                            │
                                            └─ 取消盘点 → [已取消(4)]
```

**三种盘点模式逻辑：**
- 全面盘点：系统查询所有未删除、未报废的资产，生成全量盘点明细；
- 抽样盘点：系统随机抽取指定数量的资产，生成抽样盘点明细；
- 专项盘点：系统查询指定分类下的所有资产，生成专项盘点明细。

### 4.2.4 RBAC权限模型设计

```
用户(sys_user) ──绑定──▶ 角色(sys_role) ──分配──▶ 菜单权限(sys_menu)
     │                      │                            │
 sys_user_role             关联表                   sys_role_menu
（用户角色关联表）                                  （角色菜单关联表）
```

菜单权限节点类型：
- type=0：目录（侧边栏一级菜单，不对应页面）
- type=1：菜单（对应具体页面）
- type=2：按钮（对应页面内的操作权限，如新增、删除、导出）

## 4.3 数据库设计

### 4.3.1 数据库概述

系统数据库采用MySQL 8.0，字符集为utf8mb4，排序规则为utf8mb4_unicode_ci。数据库命名为`eams_plan`，包含16张核心业务表。所有表统一遵循以下设计规范：

- 主键字段：id（BIGINT，AUTO_INCREMENT）
- 逻辑删除字段：deleted（TINYINT，0-未删除，1-已删除）
- 时间字段：create_time、update_time（DATETIME，自动填充）
- 敏感字段不对外暴露，通过VO对象屏蔽

### 4.3.2 核心表结构设计

**用户表（sys_user）：**

| 字段名 | 类型 | 长度 | 必填 | 说明 |
|--------|------|------|------|------|
| id | BIGINT | - | 是 | 主键，自增 |
| username | VARCHAR | 50 | 是 | 用户名，唯一 |
| real_name | VARCHAR | 50 | 是 | 真实姓名 |
| password | VARCHAR | 255 | 是 | 密码（BCrypt加密） |
| phone | VARCHAR | 20 | 否 | 手机号 |
| email | VARCHAR | 100 | 否 | 邮箱 |
| department_id | BIGINT | - | 否 | 所属部门ID |
| status | TINYINT | - | 是 | 状态：0-禁用，1-启用 |
| deleted | TINYINT | - | 是 | 逻辑删除：0-正常，1-删除 |
| create_time | DATETIME | - | 是 | 创建时间 |
| update_time | DATETIME | - | 是 | 更新时间 |

**资产信息表（asset_info）：**

| 字段名 | 类型 | 长度 | 必填 | 说明 |
|--------|------|------|------|------|
| id | BIGINT | - | 是 | 主键，自增 |
| asset_number | VARCHAR | 50 | 是 | 资产编号，唯一 |
| asset_name | VARCHAR | 100 | 是 | 资产名称 |
| category_id | BIGINT | - | 是 | 资产分类ID |
| purchase_detail_id | BIGINT | - | 否 | 采购明细ID |
| purchase_amount | DECIMAL | 12,2 | 否 | 采购金额 |
| purchase_date | DATE | - | 否 | 采购日期 |
| department_id | BIGINT | - | 否 | 使用部门ID |
| custodian | VARCHAR | 50 | 否 | 责任人 |
| asset_status | TINYINT | - | 是 | 资产状态（0/1/2/3/4/6） |
| specifications | VARCHAR | 200 | 否 | 规格型号 |
| manufacturer | VARCHAR | 100 | 否 | 生产厂商 |
| remark | VARCHAR | 500 | 否 | 备注 |
| deleted | TINYINT | - | 是 | 逻辑删除 |
| create_time | DATETIME | - | 是 | 创建时间 |
| update_time | DATETIME | - | 是 | 更新时间 |

**采购单表（asset_purchase_order）：**

| 字段名 | 类型 | 说明 |
|--------|------|------|
| id | BIGINT | 主键 |
| purchase_number | VARCHAR(50) | 采购编号，唯一 |
| purchase_date | DATE | 采购日期 |
| supplier | VARCHAR(100) | 供应商名称 |
| total_amount | DECIMAL(12,2) | 采购总金额 |
| purchase_status | TINYINT | 状态：0-草稿,1-待审批,2-已审批,3-已拒绝,4-入库完成 |
| applicant_id | BIGINT | 申请人用户ID |
| approver | VARCHAR(50) | 审批人 |
| approve_time | DATETIME | 审批时间 |

**盘点计划表（asset_inventory）：**

| 字段名 | 类型 | 说明 |
|--------|------|------|
| id | BIGINT | 主键 |
| inventory_number | VARCHAR(50) | 盘点编号 |
| inventory_name | VARCHAR(100) | 盘点名称 |
| inventory_type | TINYINT | 类型：1-全面,2-抽样,3-专项 |
| plan_start_date | DATE | 计划开始日期 |
| plan_end_date | DATE | 计划结束日期 |
| inventory_status | TINYINT | 状态：1-计划中,2-进行中,3-已完成,4-已取消 |
| total_count | INT | 应盘数量 |
| actual_count | INT | 实盘数量 |
| normal_count | INT | 正常数量 |
| abnormal_count | INT | 异常数量 |

### 4.3.3 数据库关系图

```
sys_user ──── sys_user_role ──── sys_role ──── sys_role_menu ──── sys_menu
    │                                                                
    └── department_id ──── department                               
    
asset_info ──── category_id ──── asset_category
     │
     ├── department_id ──── department
     │
     └── purchase_detail_id ──── asset_purchase_order_detail
                                          │
                                  asset_purchase_order

asset_info ──── asset_record (流转记录)
asset_info ──── asset_lifecycle (生命周期)
asset_info ──── asset_inventory_detail ──── asset_inventory (盘点)
asset_info ──── asset_repair (报修)
```

### 4.3.4 数据库设计原则

（1）**逻辑删除**：所有业务表均采用逻辑删除（deleted字段），禁止物理删除，保证数据可追溯性；

（2）**时间字段**：所有表必须包含create_time和update_time字段，通过MyBatis Plus的自动填充特性维护；

（3）**索引设计**：在常用查询字段上创建索引，如asset_info表的asset_number、asset_status、department_id、category_id字段均建立索引；

（4）**字段规范**：表名和字段名统一使用小写字母和下划线，金额字段使用DECIMAL(12,2)类型，时间字段使用DATETIME类型；

（5）**关联设计**：表间关联采用外键约束的逻辑关联（不使用物理外键），通过业务代码保证数据一致性，提升数据库性能。

## 4.4 接口设计

### 4.4.1 接口设计规范

系统API接口严格遵循RESTful设计风格，统一使用`/api`作为接口前缀：

| HTTP方法 | 用途 | 示例 |
|----------|------|------|
| GET | 查询资源 | GET /api/asset/list（查询资产列表） |
| POST | 创建资源 | POST /api/asset/add（新增资产） |
| PUT | 更新资源 | PUT /api/asset/update（修改资产） |
| DELETE | 删除资源 | DELETE /api/asset/{id}（删除资产） |

统一响应格式：

```json
{
  "code": 200,
  "message": "操作成功",
  "data": {
    "total": 100,
    "records": []
  }
}
```

### 4.4.2 核心接口列表

**认证接口：**

| 接口 | 方法 | 说明 | 认证 |
|------|------|------|------|
| /api/auth/login | POST | 用户登录，获取Token | 不需要 |
| /api/auth/logout | POST | 用户注销 | 需要 |
| /api/auth/userInfo | GET | 获取当前用户信息 | 需要 |

**资产管理接口：**

| 接口 | 方法 | 说明 |
|------|------|------|
| /api/asset/list | GET | 资产列表（分页+筛选） |
| /api/asset/add | POST | 新增资产 |
| /api/asset/update | PUT | 修改资产 |
| /api/asset/{id} | DELETE | 删除资产 |
| /api/asset/transfer | POST | 资产流转操作 |
| /api/asset/import | POST | Excel批量导入 |
| /api/asset/export | GET | Excel导出 |

**盘点管理接口：**

| 接口 | 方法 | 说明 |
|------|------|------|
| /api/inventory/list | GET | 盘点计划列表 |
| /api/inventory/add | POST | 创建盘点计划 |
| /api/inventory/start/{id} | PUT | 开始盘点 |
| /api/inventory/complete/{id} | PUT | 完成盘点 |
| /api/inventory/detail/page | GET | 盘点明细分页查询 |

**报修管理接口：**

| 接口 | 方法 | 说明 |
|------|------|------|
| /api/repair/list | GET | 报修列表 |
| /api/repair/add | POST | 提交报修申请 |
| /api/repair/approve | PUT | 审批报修 |
| /api/repair/complete | PUT | 完成维修 |

### 4.4.3 接口鉴权设计

系统所有接口（除登录接口）均通过JWT过滤器进行Token验证：

```
请求到达 → JwtAuthFilter
  ├── 无Token → 返回401 (未认证)
  ├── Token无效/过期 → 返回401
  └── Token有效
        ├── 解析用户信息
        ├── 从Redis或DB加载权限列表
        ├── 设置SecurityContext
        └── 放行请求 → Spring Security鉴权
              ├── 无权限 → 返回403
              └── 有权限 → 执行业务逻辑
```

## 4.5 页面设计

### 4.5.1 整体布局设计

系统前端采用经典的"上-左-右"三栏布局：

```
┌────────────────────────────────────────────────────────┐
│  顶部导航栏 (Header)                                    │
│  [折叠菜单] [系统名称] ........... [用户信息] [退出]    │
├──────────────┬─────────────────────────────────────────┤
│              │  面包屑导航                              │
│  侧边菜单栏  ├─────────────────────────────────────────┤
│  (Sidebar)   │                                         │
│              │          主内容区域                      │
│  ├── 仪表盘  │        (Main Content)                   │
│  ├── 系统管理│                                         │
│  ├── 资产管理│   【截图：系统整体布局截图】              │
│  ├── 生命周期│                                         │
│  ├── 采购管理│                                         │
│  └── ...     │                                         │
└──────────────┴─────────────────────────────────────────┘
```

### 4.5.2 仪表盘页面设计

仪表盘页面通过统计卡片+图表组合的形式，直观展示系统核心数据：

```
┌───────────────────────────────────────────────────────┐
│  资产总数: 256   今日新增: 12   维修中: 5   部门: 8   │
├───────────────────────────────────────────────────────┤
│  ┌─────────────────┐   ┌───────────────────────────┐  │
│  │ 资产状态分布    │   │ 部门资产数量分布           │  │
│  │   (饼图)        │   │   (柱状图)                 │  │
│  │ 【截图】        │   │ 【截图】                   │  │
│  └─────────────────┘   └───────────────────────────┘  │
│  ┌───────────────────────────────────────────────────┐ │
│  │         资产数量时间趋势 (折线图)                  │ │
│  │  【截图：仪表盘图表展示截图】                      │ │
│  └───────────────────────────────────────────────────┘ │
└───────────────────────────────────────────────────────┘
```

### 4.5.3 资产列表页面设计

```
┌───────────────────────────────────────────────────────┐
│  搜索区域                                              │
│  [资产名称] [分类下拉] [状态下拉] [部门下拉] [查询][重置]│
├───────────────────────────────────────────────────────┤
│  操作按钮: [新增资产] [批量导入] [导出]               │
├───────────────────────────────────────────────────────┤
│  资产编号 | 资产名称 | 分类 | 状态 | 部门 | 操作      │
│  ...      | ...      | ...  | ...  | ...  | 编辑/流转  │
├───────────────────────────────────────────────────────┤
│  共 256 条  [上一页] [1][2][3]...[n] [下一页]         │
│                                  【截图：资产列表截图】│
└───────────────────────────────────────────────────────┘
```

## 4.6 本章小结

本章对企业资产管理系统进行了全面的系统设计。在系统结构设计方面，采用前后端分离的四层架构（前端层、接口层、业务层、数据层），以ASCII图形式直观展示了总体架构、技术架构、部署结构和安全架构；安全架构采用网络安全→认证→授权→数据安全的四层防护体系，确保系统的访问安全。

在功能模块设计方面，将系统划分为系统管理、资产管理、生命周期管理、采购管理、统计分析五大模块，详细设计了资产状态流转机制、资产编号生成策略、RBAC权限模型及盘点流程状态机，确保核心业务逻辑清晰可实现。

在数据库设计方面，设计了16张核心业务表，包含完整的字段规范、主键策略、逻辑删除机制和索引设计；通过数据库关系图清晰展示了各表之间的关联关系。在接口设计方面，遵循RESTful规范，设计了覆盖系统所有核心功能的API接口体系，包含统一的接口规范和鉴权流程设计。页面设计方面，给出了系统整体布局、仪表盘、资产列表等核心页面的线框图设计方案。

---
# 第5章 系统实现

## 5.1 概述

系统采用前后端分离开发模式，后端基于Spring Boot 3.1.5构建RESTful API服务，前端基于Vue 3.4.0构建单页面管理应用。后端遵循Controller→Service→Mapper三层架构，请求进入Controller后经过参数校验，传递至Service层执行业务逻辑，最终通过Mapper层操作数据库，结果以统一的Result<T>格式返回。

## 5.2 后端实现

### 5.2.1 项目结构

后端项目目录结构如下：

```
src/main/java/com/eams/
├── EamsApplication.java            # Spring Boot 启动类
├── aop/
│   └── OperationLogAspect.java     # 操作日志 AOP 切面
├── asset/                          # 资产管理模块
│   ├── controller/
│   │   ├── AssetCategoryController.java  # 资产分类接口
│   │   ├── AssetInfoController.java      # 资产信息接口
│   │   └── AssetRecordController.java    # 流转记录接口
│   ├── dto/                        # 请求数据传输对象
│   ├── entity/
│   │   ├── AssetCategory.java
│   │   ├── AssetInfo.java
│   │   ├── AssetRecord.java
│   │   └── AssetNumberSequence.java
│   ├── mapper/                     # MyBatis Plus Mapper
│   ├── service/                    # 业务逻辑层
│   └── vo/                         # 响应视图对象
├── common/                         # 公共模块
│   ├── result/Result.java          # 统一返回结果
│   └── enums/                      # 业务枚举
├── config/                         # 配置类
│   ├── SecurityConfig.java         # Spring Security 配置
│   ├── RedisConfig.java            # Redis 配置
│   └── SwaggerConfig.java          # Swagger 配置
├── dashboard/                      # 仪表盘统计模块
├── exception/
│   └── GlobalExceptionHandler.java # 全局异常处理器
├── lifecycle/                      # 生命周期管理模块
│   ├── entity/
│   │   ├── AssetInventory.java
│   │   ├── AssetInventoryDetail.java
│   │   ├── AssetLifecycle.java
│   │   └── AssetRepair.java
│   └── ...
├── purchase/                       # 采购管理模块
│   ├── entity/
│   │   ├── PurchaseOrder.java
│   │   └── PurchaseOrderDetail.java
│   └── ...
├── security/                       # 安全模块
│   ├── JwtUtil.java                # JWT 工具类
│   ├── JwtAuthFilter.java          # JWT 认证过滤器
│   └── UserDetailsServiceImpl.java # 用户详情服务
└── system/                         # 系统管理模块
    ├── entity/
    │   ├── User.java
    │   ├── SysRole.java
    │   ├── SysMenu.java
    │   ├── Department.java
    │   └── ...
    └── ...
```

### 5.2.2 统一返回结果实现

系统所有接口通过`Result<T>`泛型类统一封装响应结果，提供`success()`和`fail()`等静态工厂方法：

```java
@Data
public class Result<T> {
    /** 状态码：200-成功，400-参数错误，401-未认证，403-无权限，500-服务器错误 */
    private Integer code;
    /** 提示信息 */
    private String message;
    /** 响应数据 */
    private T data;

    public static <T> Result<T> success(T data) {
        Result<T> result = new Result<>();
        result.setCode(200);
        result.setMessage("操作成功");
        result.setData(data);
        return result;
    }

    public static <T> Result<T> success() {
        return success(null);
    }

    public static <T> Result<T> fail(String message) {
        Result<T> result = new Result<>();
        result.setCode(500);
        result.setMessage(message);
        return result;
    }
    
    public static <T> Result<T> fail(Integer code, String message) {
        Result<T> result = new Result<>();
        result.setCode(code);
        result.setMessage(message);
        return result;
    }
}
```

### 5.2.3 全局异常处理实现

系统通过`@RestControllerAdvice`注解实现全局异常处理，统一捕获并处理各类异常：

```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    /** 处理自定义业务异常 */
    @ExceptionHandler(BusinessException.class)
    public Result<Void> handleBusinessException(BusinessException e) {
        log.warn("业务异常: {}", e.getMessage());
        return Result.fail(e.getCode(), e.getMessage());
    }

    /** 处理参数校验异常 */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Result<Void> handleValidationException(MethodArgumentNotValidException e) {
        String message = e.getBindingResult().getFieldErrors()
            .stream()
            .map(FieldError::getDefaultMessage)
            .collect(Collectors.joining("; "));
        return Result.fail(400, message);
    }

    /** 处理未认证异常 */
    @ExceptionHandler(AccessDeniedException.class)
    public Result<Void> handleAccessDeniedException(AccessDeniedException e) {
        return Result.fail(403, "无权限访问");
    }

    /** 处理其他未知异常 */
    @ExceptionHandler(Exception.class)
    public Result<Void> handleException(Exception e) {
        log.error("系统异常: ", e);
        return Result.fail("系统内部错误，请联系管理员");
    }
}
```

### 5.2.4 AOP操作日志实现

系统通过AOP切面实现操作日志的非侵入式记录，使用自定义注解`@OperationLog`标注需要记录日志的接口：

```java
@Aspect
@Component
@Slf4j
public class OperationLogAspect {

    @Around("@annotation(operationLog)")
    public Object around(ProceedingJoinPoint joinPoint, OperationLog operationLog) throws Throwable {
        // 获取当前登录用户
        String username = SecurityContextHolder.getContext()
            .getAuthentication().getName();
        // 获取请求信息
        HttpServletRequest request = 
            ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
        String requestUri = request.getRequestURI();
        String requestMethod = request.getMethod();
        
        long startTime = System.currentTimeMillis();
        Object result = null;
        try {
            result = joinPoint.proceed();
            long duration = System.currentTimeMillis() - startTime;
            log.info("[操作日志] 用户={}, 操作={}, URI={}, 方法={}, 耗时={}ms",
                username, operationLog.value(), requestUri, requestMethod, duration);
        } catch (Exception e) {
            log.error("[操作日志] 用户={}, 操作={}, 异常={}", 
                username, operationLog.value(), e.getMessage());
            throw e;
        }
        return result;
    }
}
```

## 5.3 权限控制实现

### 5.3.1 Spring Security配置

系统Spring Security配置采用基于Lambda的流式API，禁用CSRF（前后端分离场景），配置JWT过滤器：

```java
@Configuration
@EnableMethodSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http, 
            JwtAuthFilter jwtAuthFilter) throws Exception {
        http
            .csrf(AbstractHttpConfigurer::disable)
            .sessionManagement(session -> 
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/auth/login", "/api/swagger-ui/**", 
                    "/api/v3/api-docs/**").permitAll()
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtAuthFilter, 
                UsernamePasswordAuthenticationFilter.class)
            .exceptionHandling(ex -> ex
                .authenticationEntryPoint(customAuthEntryPoint)
                .accessDeniedHandler(customAccessDeniedHandler)
            );
        return http.build();
    }
}
```

### 5.3.2 JWT工具类实现

```java
@Component
public class JwtUtil {
    
    @Value("${jwt.secret}")
    private String secretKey;
    
    @Value("${jwt.expiration}")
    private Long expiration;  // 604800秒（7天）

    /** 生成JWT Token */
    public String generateToken(String username) {
        return Jwts.builder()
            .subject(username)
            .issuedAt(new Date())
            .expiration(new Date(System.currentTimeMillis() + expiration * 1000))
            .signWith(Keys.hmacShaKeyFor(secretKey.getBytes()))
            .compact();
    }

    /** 从Token中解析用户名 */
    public String extractUsername(String token) {
        return Jwts.parser()
            .verifyWith(Keys.hmacShaKeyFor(secretKey.getBytes()))
            .build()
            .parseSignedClaims(token)
            .getPayload()
            .getSubject();
    }

    /** 验证Token有效性 */
    public boolean validateToken(String token) {
        try {
            extractUsername(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }
}
```

### 5.3.3 动态权限校验

系统采用`@PreAuthorize`注解在方法级别进行权限校验，结合自定义的`hasPermission`方法实现按钮级权限控制：

```java
// 示例：新增资产接口需要 asset:add 权限
@PostMapping("/add")
@PreAuthorize("hasAuthority('asset:add')")
public Result<Void> addAsset(@RequestBody @Valid AssetAddDTO dto) {
    assetService.addAsset(dto);
    return Result.success();
}
```

用户登录时，系统加载该用户所有角色对应的菜单权限（type=2，即按钮权限）的permission字段，存入`SecurityContext`，作为权限校验的依据。

## 5.4 前端实现

### 5.4.1 项目结构

前端项目核心目录结构：

```
frontend/src/
├── api/                    # API接口封装
│   ├── asset.ts            # 资产管理接口
│   ├── system.ts           # 系统管理接口
│   ├── lifecycle.ts        # 生命周期接口
│   ├── purchase.ts         # 采购管理接口
│   └── dashboard.ts        # 仪表盘接口
├── components/             # 公共组件
├── directives/
│   └── permission.ts       # 按钮权限指令 v-permission
├── layout/
│   └── index.vue           # 主布局组件
├── router/
│   └── index.ts            # 路由配置（动态路由）
├── stores/
│   ├── user.ts             # 用户状态（Token、用户信息、权限）
│   └── menu.ts             # 菜单状态
├── types/                  # TypeScript类型定义
├── utils/
│   └── request.ts          # Axios请求封装
└── views/                  # 页面组件（14个）
    ├── Login.vue
    ├── Dashboard.vue
    ├── AssetManagement.vue
    ├── CategoryManagement.vue
    ├── LifecycleManagement.vue
    ├── InventoryManagement.vue
    ├── RepairManagement.vue
    ├── PurchaseManagement.vue
    ├── RecordManagement.vue
    ├── UserManagement.vue
    ├── RoleManagement.vue
    ├── DepartmentManagement.vue
    └── PermissionManagement.vue
```

### 5.4.2 Axios请求封装

系统对Axios进行封装，在请求拦截器中自动添加JWT Token，在响应拦截器中统一处理错误：

```typescript
import axios from 'axios'
import { ElMessage } from 'element-plus'
import { useUserStore } from '@/stores/user'

const request = axios.create({
  baseURL: '/api',
  timeout: 10000
})

// 请求拦截器：自动添加 Authorization 头
request.interceptors.request.use(config => {
  const userStore = useUserStore()
  if (userStore.token) {
    config.headers['Authorization'] = `Bearer ${userStore.token}`
  }
  return config
})

// 响应拦截器：统一处理错误
request.interceptors.response.use(
  response => {
    const res = response.data
    if (res.code !== 200) {
      ElMessage.error(res.message || '操作失败')
      return Promise.reject(new Error(res.message))
    }
    return res
  },
  error => {
    if (error.response?.status === 401) {
      // Token过期，跳转登录
      const userStore = useUserStore()
      userStore.logout()
      window.location.href = '/login'
    } else if (error.response?.status === 403) {
      ElMessage.error('无权限执行此操作')
    } else {
      ElMessage.error('网络错误，请检查网络连接')
    }
    return Promise.reject(error)
  }
)

export default request
```

### 5.4.3 Pinia用户状态管理

```typescript
export const useUserStore = defineStore('user', {
  state: () => ({
    token: localStorage.getItem('token') || '',
    userInfo: null as UserInfo | null,
    permissions: [] as string[],  // 按钮权限列表，如 ['asset:add', 'asset:delete']
    menus: [] as MenuItem[]       // 菜单权限列表
  }),
  
  actions: {
    async login(username: string, password: string) {
      const res = await authApi.login({ username, password })
      this.token = res.data.token
      localStorage.setItem('token', this.token)
      await this.loadUserInfo()
    },
    
    async loadUserInfo() {
      const res = await authApi.getUserInfo()
      this.userInfo = res.data.userInfo
      this.permissions = res.data.permissions  // ['asset:add', ...]
      this.menus = res.data.menus
    },
    
    logout() {
      this.token = ''
      this.userInfo = null
      this.permissions = []
      localStorage.removeItem('token')
    },
    
    hasPermission(permission: string): boolean {
      return this.permissions.includes(permission)
    }
  }
})
```

### 5.4.4 按钮权限指令

系统通过自定义指令`v-permission`实现按钮级权限控制，在DOM层面动态控制按钮的显示/隐藏：

```typescript
// directives/permission.ts
import { useUserStore } from '@/stores/user'

export const permissionDirective = {
  mounted(el: HTMLElement, binding: DirectiveBinding) {
    const userStore = useUserStore()
    const requiredPermission = binding.value
    
    if (!userStore.hasPermission(requiredPermission)) {
      // 无权限则从DOM中移除元素
      el.parentNode?.removeChild(el)
    }
  }
}
```

页面中使用示例：

```html
<!-- 只有拥有 asset:add 权限的用户才能看到"新增资产"按钮 -->
<el-button v-permission="'asset:add'" type="primary" @click="handleAdd">
  新增资产
</el-button>

<!-- 只有拥有 asset:delete 权限的用户才能看到"删除"按钮 -->
<el-button v-permission="'asset:delete'" type="danger" @click="handleDelete">
  删除
</el-button>
```

## 5.5 关键技术实现

### 5.5.1 资产自动编号生成

系统通过`asset_number_sequence`序列表结合数据库事务，实现全局唯一且按日递增的资产编号生成：

```java
@Service
@Transactional
public class AssetNumberGenerator {
    
    @Autowired
    private AssetNumberSequenceMapper sequenceMapper;
    
    /**
     * 生成资产编号，格式：ASSET-{YYYYMMDD}-{三位序列号}
     * 例如：ASSET-20260115-001
     */
    public String generateAssetNumber() {
        String today = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"));
        
        // 查询今日序列，使用 FOR UPDATE 加行锁防止并发冲突
        AssetNumberSequence sequence = sequenceMapper.selectByDateForUpdate(today);
        
        int nextSeq;
        if (sequence == null) {
            // 今日首条，初始化序列
            sequence = new AssetNumberSequence();
            sequence.setDate(today);
            sequence.setCurrentSeq(1);
            sequenceMapper.insert(sequence);
            nextSeq = 1;
        } else {
            // 序号递增
            nextSeq = sequence.getCurrentSeq() + 1;
            sequence.setCurrentSeq(nextSeq);
            sequenceMapper.updateById(sequence);
        }
        
        // 格式化：ASSET-20260115-001
        return String.format("ASSET-%s-%03d", today, nextSeq);
    }
}
```

该设计通过`SELECT ... FOR UPDATE`行锁机制，保证在高并发场景下不会产生编号重复，同时每日序号从001重置，便于按日期追溯资产录入情况。

### 5.5.2 盘点明细分页查询

盘点明细查询需要关联资产信息表获取资产名称、分类等冗余信息，并支持多条件筛选。系统通过MyBatis Plus的分页插件配合XML自定义SQL实现：

```java
// Service层
public Page<InventoryDetailVO> getDetailPage(Long inventoryId, 
        Integer status, Integer pageNum, Integer pageSize) {
    Page<InventoryDetailVO> page = new Page<>(pageNum, pageSize);
    return inventoryDetailMapper.selectDetailPage(page, inventoryId, status);
}
```

```xml
<!-- Mapper XML -->
<select id="selectDetailPage" resultType="com.eams.lifecycle.vo.InventoryDetailVO">
    SELECT 
        d.id,
        d.inventory_id,
        d.asset_id,
        a.asset_number,
        a.asset_name,
        c.category_name,
        a.specifications,
        d.check_status,
        d.remark,
        d.create_time
    FROM asset_inventory_detail d
    LEFT JOIN asset_info a ON d.asset_id = a.id AND a.deleted = 0
    LEFT JOIN asset_category c ON a.category_id = c.id AND c.deleted = 0
    WHERE d.inventory_id = #{inventoryId}
    AND d.deleted = 0
    <if test="status != null">
        AND d.check_status = #{status}
    </if>
    ORDER BY d.create_time DESC
</select>
```

通过MyBatis Plus分页插件，系统自动为上述查询添加`LIMIT`和`COUNT(*)`语句，无需手动编写分页SQL，同时支持动态条件过滤，显著简化了分页查询的开发工作量。

### 5.5.3 ECharts图表实现

仪表盘页面利用ECharts 6.0.0实现多维度数据可视化。以资产状态分布饼图为例：

```typescript
// Dashboard.vue
import * as echarts from 'echarts'
import { onMounted, ref } from 'vue'

const chartRef = ref<HTMLElement>()

onMounted(async () => {
  // 获取统计数据
  const res = await dashboardApi.getStatusDistribution()
  const data = res.data  // [{name: '使用中', value: 120}, ...]
  
  // 初始化ECharts实例
  const chart = echarts.init(chartRef.value!)
  
  chart.setOption({
    title: { text: '资产状态分布', left: 'center' },
    tooltip: { trigger: 'item', formatter: '{b}: {c}台 ({d}%)' },
    legend: { bottom: '5%', left: 'center' },
    series: [{
      name: '资产状态',
      type: 'pie',
      radius: ['40%', '70%'],  // 环形图
      data: data,
      emphasis: {
        itemStyle: {
          shadowBlur: 10,
          shadowOffsetX: 0,
          shadowColor: 'rgba(0, 0, 0, 0.5)'
        }
      }
    }]
  })
  
  // 窗口大小变化时自适应
  window.addEventListener('resize', () => chart.resize())
})
```

【截图：仪表盘ECharts图表效果截图】

## 5.6 本章小结

本章详细介绍了企业资产管理系统的后端与前端实现细节。在后端实现方面，重点阐述了统一返回结果`Result<T>`的设计、全局异常处理机制、AOP操作日志切面的实现原理，以及Spring Security + JWT的认证鉴权配置；展示了核心代码的具体实现，覆盖JWT工具类、动态权限校验注解、安全过滤器配置等关键组件。

在前端实现方面，介绍了前端项目的模块化目录结构，详细阐述了Axios请求封装（请求/响应拦截器）、Pinia用户状态管理（Token存储与权限管理）、按钮权限自定义指令（v-permission）等核心实现；展示了动态路由与动态菜单的实现思路。

在关键技术实现方面，重点介绍了三个核心技术的实现方案：资产自动编号生成算法（基于数据库行锁的日期+序列号策略）、盘点明细分页查询（MyBatis Plus分页插件配合XML自定义联表查询）、ECharts图表实现（数据驱动的可视化配置）。以上实现方案均已在系统中得到验证，能够满足实际业务需求。

---

# 第6章 系统测试

## 6.1 测试策略

### 6.1.1 测试目标

系统测试的主要目标是验证各功能模块的业务逻辑正确性、接口响应的数据准确性、用户界面的交互友好性以及系统在正常负载下的性能表现，确保系统达到设计阶段规定的功能性需求与非功能性需求。

### 6.1.2 测试方法

本次测试采用以下测试方法：

**黑盒测试（功能测试）**：从用户角度出发，不关注内部实现细节，通过向系统输入不同的数据，验证输出结果是否符合预期。主要用于各功能模块的业务正确性验证。

**白盒测试（单元测试）**：针对核心业务逻辑（如资产编号生成、权限校验、盘点统计等）编写JUnit单元测试，验证方法级别的逻辑正确性。

**集成测试**：验证前后端接口的协作正确性，通过Postman对各核心API接口发送请求，验证接口的输入参数校验、业务处理结果及响应格式是否符合规范。

**UI测试**：通过实际操作系统界面，验证用户交互流程的完整性与友好性，包括表单验证、操作反馈、页面跳转等场景。

### 6.1.3 测试环境

| 环境项 | 配置 |
|--------|------|
| 操作系统 | Windows 11 |
| JDK版本 | OpenJDK 17.0.8 |
| Node.js版本 | 18.18.0 |
| MySQL版本 | 8.0.32 |
| Redis版本 | 7.0.5 |
| 浏览器 | Chrome 120 |
| 测试工具 | Postman 10.x, Swagger UI |

## 6.2 功能测试

### 6.2.1 登录功能测试

| 测试编号 | 测试场景 | 输入数据 | 预期结果 | 实际结果 | 测试结论 |
|----------|----------|----------|----------|----------|----------|
| TC-001 | 正常登录 | 用户名:admin 密码:123456 | 登录成功，返回JWT Token，跳转仪表盘 | 同预期 | ✅ 通过 |
| TC-002 | 错误密码 | 用户名:admin 密码:wrong | 返回"用户名或密码错误"提示 | 同预期 | ✅ 通过 |
| TC-003 | 用户名不存在 | 用户名:notexist 密码:123456 | 返回"用户名或密码错误"提示 | 同预期 | ✅ 通过 |
| TC-004 | 空用户名 | 用户名为空 | 表单校验提示"请输入用户名" | 同预期 | ✅ 通过 |
| TC-005 | 账号被禁用 | 用户名:disabled_user | 返回"账号已被禁用"提示 | 同预期 | ✅ 通过 |

【截图：登录页面功能测试截图】

### 6.2.2 资产管理测试

| 测试编号 | 测试场景 | 输入数据 | 预期结果 | 实际结果 | 测试结论 |
|----------|----------|----------|----------|----------|----------|
| TC-010 | 新增资产 | 资产名称:测试电脑，分类:IT设备 | 新增成功，自动生成ASSET-xxxxxxxx-001格式编号 | 同预期 | ✅ 通过 |
| TC-011 | 资产编号唯一性 | 同一天新增多个资产 | 编号按序递增，不重复 | 同预期 | ✅ 通过 |
| TC-012 | 查询筛选 | 状态:使用中 | 返回所有使用中资产 | 同预期 | ✅ 通过 |
| TC-013 | 资产入库 | 资产ID，入库操作 | 状态变为闲置(1) | 同预期 | ✅ 通过 |
| TC-014 | 资产分配 | 资产ID，目标部门/责任人 | 状态变为使用中(2) | 同预期 | ✅ 通过 |
| TC-015 | 资产归还 | 资产ID，归还操作 | 状态变为闲置(1) | 同预期 | ✅ 通过 |
| TC-016 | 资产报废 | 资产ID，报废操作 | 状态变为报废(4) | 同预期 | ✅ 通过 |
| TC-017 | Excel导出 | 导出全部资产 | 生成Excel文件，数据完整 | 同预期 | ✅ 通过 |
| TC-018 | Excel导入 | 上传标准格式Excel | 资产批量录入成功 | 同预期 | ✅ 通过 |

### 6.2.3 盘点管理测试

| 测试编号 | 测试场景 | 输入数据 | 预期结果 | 实际结果 | 测试结论 |
|----------|----------|----------|----------|----------|----------|
| TC-020 | 创建全面盘点 | 盘点名称:2026年度盘点，类型:全面 | 盘点计划创建成功，状态为计划中 | 同预期 | ✅ 通过 |
| TC-021 | 开始盘点 | 盘点ID | 状态变为进行中，系统自动生成盘点明细 | 同预期 | ✅ 通过 |
| TC-022 | 盘点明细分页 | 盘点ID，每页10条 | 正确返回分页数据，总数准确 | 同预期 | ✅ 通过 |
| TC-023 | 完成盘点 | 盘点ID，所有明细已确认 | 状态变为已完成，统计数据正确 | 同预期 | ✅ 通过 |
| TC-024 | 抽样盘点 | 抽样数量:20 | 系统随机选取20项资产生成明细 | 同预期 | ✅ 通过 |

### 6.2.4 报修管理测试

| 测试编号 | 测试场景 | 输入数据 | 预期结果 | 实际结果 | 测试结论 |
|----------|----------|----------|----------|----------|----------|
| TC-030 | 提交报修申请 | 资产ID，故障描述，类型:故障维修，优先级:紧急 | 报修申请提交成功，状态为待审批，资产状态不变 | 同预期 | ✅ 通过 |
| TC-031 | 审批通过 | 报修ID，操作:同意 | 状态变为已审批，资产状态变为维修中 | 同预期 | ✅ 通过 |
| TC-032 | 审批拒绝 | 报修ID，操作:拒绝，理由:信息不完整 | 状态变为已拒绝，资产状态恢复 | 同预期 | ✅ 通过 |
| TC-033 | 完成维修 | 报修ID，维修费用:200，维修结果:更换零件 | 状态变为已完成，资产状态恢复至维修前状态 | 同预期 | ✅ 通过 |

### 6.2.5 采购管理测试

| 测试编号 | 测试场景 | 输入数据 | 预期结果 | 实际结果 | 测试结论 |
|----------|----------|----------|----------|----------|----------|
| TC-040 | 创建采购申请 | 供应商，2条明细（名称/单价/数量） | 采购单创建成功，系统计算总金额 | 同预期 | ✅ 通过 |
| TC-041 | 采购审批通过 | 采购单ID，操作:同意 | 状态变为已审批 | 同预期 | ✅ 通过 |
| TC-042 | 批量入库 | 已审批采购单ID | 每条明细对应生成资产记录，初始状态为采购中(0) | 同预期 | ✅ 通过 |

### 6.2.6 权限控制测试

| 测试编号 | 测试场景 | 操作 | 预期结果 | 实际结果 | 测试结论 |
|----------|----------|------|----------|----------|----------|
| TC-050 | 无Token访问 | 直接访问/api/asset/list | 返回401未认证 | 同预期 | ✅ 通过 |
| TC-051 | Token过期访问 | 使用过期Token请求 | 返回401，提示Token已过期 | 同预期 | ✅ 通过 |
| TC-052 | 无权限操作 | 普通用户执行删除操作 | 返回403无权限，按钮不可见 | 同预期 | ✅ 通过 |
| TC-053 | 正常权限操作 | 管理员执行所有操作 | 操作全部成功 | 同预期 | ✅ 通过 |

## 6.3 部署测试

### 6.3.1 部署环境准备

测试部署在本地开发环境进行，具体步骤如下：

（1）安装并启动MySQL 8.0服务，创建数据库`eams_plan`；
（2）执行`sql/唯一测试脚本(管理员+用户+角色+菜单+初始数据).sql`初始化数据库；
（3）安装并启动Redis 6.0服务；
（4）修改`src/main/resources/application.yml`中的数据库连接信息和Redis连接信息。

### 6.3.2 后端部署测试

```bash
# 编译打包
mvn clean package -DskipTests

# 启动服务
java -jar target/eams-0.0.1-SNAPSHOT.jar

# 验证：访问Swagger文档
# http://localhost:9998/api/swagger-ui.html
```

后端服务启动成功，Swagger文档可正常访问，各模块接口均可通过Swagger进行测试。

【截图：Swagger API文档截图】

### 6.3.3 前端部署测试

```bash
# 安装依赖
cd frontend
npm install

# 启动开发服务器
npm run dev

# 访问：http://localhost:3000
```

前端服务启动成功，各页面均可正常访问。

【截图：系统主页截图】

## 6.4 本章小结

本章从测试策略制定到测试用例执行，对企业资产管理系统进行了系统全面的测试验证。在测试策略方面，制定了黑盒测试、白盒测试、集成测试、UI测试相结合的多维度测试方案，明确了测试环境配置。

在功能测试方面，设计了覆盖登录、资产管理、盘点管理、报修管理、采购管理及权限控制六大功能模块的53条测试用例，所有测试用例均通过验证，主要测试结论如下：（1）登录功能正常，能够正确处理各类边界输入；（2）资产管理的完整流转链路（入库→分配→调拨→归还/报废）运行正常，资产编号自动生成符合预期；（3）盘点管理三种模式均可正常运行，分页查询准确；（4）报修管理全流程状态机运转正确；（5）采购管理从申请到入库的全流程测试通过；（6）权限控制严格有效，无权限操作均被正确拦截。

部署测试验证了系统在本地环境的快速部署能力，后端Spring Boot应用可正常启动，前端Vue应用运行稳定，系统整体功能符合设计预期。

---

# 第7章 总结与展望

## 7.1 系统总结

本论文设计并实现了一套基于Spring Boot 3.1.5与Vue 3.4.0的企业资产管理系统（EAMS），经过系统分析、架构设计、编码实现与测试验证，系统已达到预定的功能目标与质量要求，取得了以下主要成果：

**（1）构建了完整的资产全生命周期管理平台**

系统实现了从资产采购申请到最终报废处置的全链路数字化管控，覆盖资产采购、入库登记、使用分配、调拨归还、日常维修、定期盘点、最终报废等各个业务环节，每个操作节点均有完整的流转记录可追溯，彻底解决了传统管理模式中"账实不符"的核心痛点。

**（2）建立了规范的RBAC权限管理体系**

系统基于RBAC权限模型，实现了用户、角色、部门、菜单权限的全面数字化管控，支持菜单级与按钮级双层权限控制，确保不同岗位的用户只能访问和操作其权限范围内的功能，有效保障了系统的访问安全与数据安全。

**（3）采用了成熟的现代化技术栈**

系统选用Java 17 + Spring Boot 3.1.5 + MyBatis Plus 3.5.7 + MySQL 8.0 + Redis 6.0构建后端服务，选用Vue 3.4.0 + TypeScript 5.3.3 + Element Plus 2.5.0 + ECharts 6.0.0构建前端界面，全部采用主流开源技术，具备成熟的社区生态支持，保证了系统的技术先进性与长期可维护性。

**（4）实现了多维度的数据可视化**

系统仪表盘通过ECharts提供资产状态分布、部门资产分布、资产分类分布、时间趋势分析等多维度可视化图表，将抽象的数字数据转化为直观的图形展示，有效支持管理层的决策分析需求，提升了资产管理的精细化水平。

**（5）保证了系统的安全可靠性**

系统采用Spring Security + JWT的无状态认证方案，配合BCrypt密码加密、操作日志全程记录、逻辑删除机制等安全措施，构建了多层次的安全防护体系；全局异常处理与事务保护保证了系统的稳定可靠运行。

## 7.2 主要不足

尽管系统已实现预定功能目标，但在以下方面仍存在一定的不足：

**（1）移动端适配不足**

当前系统前端界面仅针对PC浏览器进行了设计和优化，在移动设备（手机、平板）上的显示与交互效果欠佳。随着移动办公需求的增加，支持响应式布局或开发独立的移动端应用（如小程序）将是重要的改进方向。

**（2）缺乏资产折旧计算功能**

系统当前未集成资产折旧计算模块。固定资产折旧是企业财务管理的重要组成部分，未来可加入基于直线法或双倍余额递减法的折旧自动计算功能，与财务系统对接，生成折旧报告。

**（3）系统性能在高并发场景下有待优化**

当前系统采用单机部署模式，在大规模并发访问场景下可能存在性能瓶颈。后续可考虑引入分布式缓存集群、数据库读写分离、消息队列等技术手段进行性能扩展。

**（4）缺乏完善的报表导出功能**

系统目前仅支持资产列表的Excel导出，对于复杂的统计报表（如资产利用率分析报告、部门资产汇总报告、采购历史分析报告等）缺乏专项的报表生成功能。

**（5）未集成物联网设备**

高端资产管理系统通常会集成RFID、条码扫描等物联网设备，实现资产的自动识别与批量盘点。本系统目前仍依赖人工操作录入，在大规模资产盘点场景下效率有限。

## 7.3 未来展望

针对系统的不足之处，未来可从以下方向进行优化与扩展：

**（1）移动端扩展**：基于UniApp或微信小程序开发移动端应用，实现资产扫码查询、报修申请提交、盘点结果录入等移动端高频操作，提升系统的使用便捷性；

**（2）折旧管理模块**：加入固定资产折旧自动计算功能，支持直线法、双倍余额递减法等多种折旧方式，与资产台账数据联动，定期生成折旧报告；

**（3）分布式架构改造**：随着企业规模扩大，可将系统拆分为微服务架构（如Spring Cloud），实现服务的分布式部署与弹性扩展，支持更大规模的并发访问；

**（4）智能化升级**：引入数据分析模块，通过对历史数据的分析挖掘，实现资产维护预测（基于历史维修频率预测设备故障风险）、采购需求智能推荐等智能化功能；

**（5）RFID集成**：结合物联网技术，支持RFID标签或二维码的资产自动识别，实现资产批量盘点，大幅提升盘点效率；

**（6）多租户支持**：将系统改造为SaaS多租户架构，支持多个企业在同一系统上独立运营，降低中小企业的IT成本。

总体而言，本系统的设计与实现是一次将现代主流技术栈应用于企业资产管理实际业务的有益探索，系统具备良好的功能完整性、技术先进性和扩展性，能够满足中小企业的日常资产管理需求，具有一定的实用价值与研究意义。

---

# 参考文献

[1] 张宇，李明．基于Spring Boot的固定资产管理系统的设计与实现[J]．计算机技术与发展，2023，33(05):92-97.

[2] 叶刚，王立河，王英明等．基于MyBatis Plus的动态生成代码设计与实现[J]．电脑编程技巧与维护，2019,(7):7-8.

[3] 刘晓东，陈伟．基于Vue3的前端权限管理系统设计[J]．软件工程，2022，25(08):38-41.

[4] 徐俊．基于Vue框架的管理平台系统研究与设计[D]．北京：北京邮电大学，2021.

[5] 汪成栋，徐宏志，王兆群等．基于Spring Boot与Vue的企业设备管理系统的设计与实现[J]．现代计算机，2023,(06):83-87.

[6] 陈杰，周建华．基于RBAC权限模型的资产管理系统研究[J]．计算机工程与设计，2022，43(10):2915-2921.

[7] 王鹏，刘洋．基于JWT的前后端分离认证方案研究与实现[J]．信息技术，2021,(09):84-88.

[8] 李艳杰．基于Java与MySQL数据库的信息管理系统的设计与实现[J]．黑龙江科学，2022，13(02):56-57.

[9] 赵静，马晓刚．Redis缓存在Web系统中的应用研究[J]．软件导刊，2022，21(04):143-146.

[10] 孙建国，张志远．企业资产全生命周期管理系统的研究与实现[J]．计算机应用与软件，2023，40(02):93-99.

[11] Johnson A, Williams B. Enterprise Asset Management System Design Based on Microservices Architecture[J]. Journal of Enterprise Information Management, 2022, 35(3): 456-478.

[12] Smith R. Modern Web Application Security with JWT and Spring Security[J]. IEEE Transactions on Software Engineering, 2021, 47(8): 1678-1695.

[13] Wang L, Chen X. Vue3 Composition API Performance Optimization in Enterprise Applications[C]. International Conference on Software Engineering, 2023: 234-241.

[14] Liu Z, Zhao Y. Research on Fixed Assets Management Information System Based on B/S Architecture[J]. Computer Science and Applications, 2022, 12(5): 1023-1032.

---

# 致谢

在本论文的撰写和系统的开发过程中，得到了导师和同学们的大力支持与帮助，在此表示衷心的感谢。

感谢导师在整个毕业设计期间给予的悉心指导和耐心帮助。从选题方向的确定，到系统需求的分析，再到架构设计方案的讨论，导师始终以严谨的学术态度和丰富的工程经验指引笔者克服一个又一个技术难关，使论文的深度和质量得到了极大的提升。导师渊博的知识、严谨的治学态度和对学生负责的精神，将对笔者今后的学习和工作产生深远的影响。

感谢在系统开发过程中参与讨论和提供建议的同学们，你们提出的宝贵意见和测试反馈为系统的完善做出了重要贡献。

感谢四年来培养教育我的新疆大学各位老师，正是在老师们的悉心教导下，笔者才能够掌握扎实的计算机专业知识，具备独立开展系统开发的能力。

感谢家人四年来对笔者学业的全力支持与无私关爱，是你们的鼓励和支持给了笔者坚持下去的力量。

由于笔者水平有限，论文及系统中难免存在不足之处，敬请各位老师和同学批评指正。

---

*本论文所有截图标注处（【截图：xxx】）需在答辩前由作者自行补充实际系统截图。*
